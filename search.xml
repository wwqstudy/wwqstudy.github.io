<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>od使用</title>
      <link href="/2022/011152450.html"/>
      <url>/2022/011152450.html</url>
      
        <content type="html"><![CDATA[<h2 id="od部分原理"><a href="#od部分原理" class="headerlink" title="od部分原理"></a>od部分原理</h2><h3 id="常见断点之INT3断点原理"><a href="#常见断点之INT3断点原理" class="headerlink" title="常见断点之INT3断点原理"></a>常见断点之INT3断点原理</h3><ol><li>原理<br>F2断点又叫做CC断点（INT3）断点。<br>01 替换指令，也就是替换int3指令<br>02 od检测到int3指令之后会产生一个异常处理并捕获它，这时候程序就会中断<br>03 od删除int3指令，还原之前代码  </li><li>优点<br>可以无限下int3断点  </li><li>缺点<br>太容易被检测到  </li></ol><h3 id="INT3断点的反调试与反反调试"><a href="#INT3断点的反调试与反反调试" class="headerlink" title="INT3断点的反调试与反反调试"></a>INT3断点的反调试与反反调试</h3><ol><li><p>知识点<br>01 FARPROC结构体<br>02 GetprocAddress()函数:检索指定的动态链接库(DLL)中的输出库函数地址。<br>03 LoadLibrary()函数:将指定的模块加载到调用进程的地址空间中。指定的模块可能会导致其他模块被加载。对于其他加载选项，请使用 LoadLibraryEx函数。  </p></li><li><p>函数原型<br>GetprocAddress()函数原型：</p><pre><code class="c"> FARPROC GetProcAddress(       HMODULE   hModule,    // DLL模块句柄       LPCSTR       lpProcName   // 函数名   );  </code></pre></li><li><p>代码  </p><pre><code class="c"> #include &lt;iostream&gt; #include &lt;Windows.h&gt; int main() &#123;     FARPROC addr = GetProcAddress(LoadLibrary(L&quot;user32.dll&quot;), &quot;MessageBoxA&quot;);     byte byteAdder = *(byte*)addr;     ::MessageBoxA(NULL, &quot;内容&quot;, &quot;标题&quot;, MB_OK);//调用MessageBoxA()     if (byteAdder == 0xCC) &#123;         printf(&quot;检测到非法调试&quot;);     &#125;     else &#123;         printf(&quot;程序正常运行&quot;);     &#125;     getchar(); &#125;  </code></pre></li><li><p>反调试<br>未进行调试时:<br><img src="/2022/011152450/1.png" alt=" "><br>对MessageBoxA()进行下断点:<br><img src="/2022/011152450/2.png" alt=" ">  </p></li><li><p>反反调试<br>在MessageBoxA()下面一行代码下INT3断点<br><img src="/2022/011152450/3.png" alt=" "><br><img src="/2022/011152450/1.png" alt=" ">  </p></li></ol><h3 id="常用断点之硬件断点"><a href="#常用断点之硬件断点" class="headerlink" title="常用断点之硬件断点"></a>常用断点之硬件断点</h3><ol><li>调试寄存器<br>DR0–DR7<br>DR0–DR3 :保存断点地址 ;DR4–DR5 ;DR6 :状态寄存器 ;DR7 :控制寄存器  </li><li>原理<br>DR0–DR3 :保存下硬件断点的地址<br>DR7 :设置相对应的控制位<br>当运行到此位置是会发送一个异常信息，导致程序中断，等待用户操作  </li><li>优点 ：不易被检测，速度快<br>缺点 : 只能下四个断点  </li></ol><h3 id="常用断点之内存断点"><a href="#常用断点之内存断点" class="headerlink" title="常用断点之内存断点"></a>常用断点之内存断点</h3><ol><li>原理<br>在该位置下内存断点，导致该位置赋予不可读、不可写、不可执行的属性，从而运行到此处时发送异常，导致程序中断。  </li><li>优点：不改变汇编代码<br>缺点：无  </li></ol><h3 id="常见断点之消息断点"><a href="#常见断点之消息断点" class="headerlink" title="常见断点之消息断点"></a>常见断点之消息断点</h3><ol><li>原理<br>当点击或者处理一个事件时，会形成消息，想内核发送，内核进行识别并做出相应的处理  </li></ol><h3 id="常见断点之条件断点"><a href="#常见断点之条件断点" class="headerlink" title="常见断点之条件断点"></a>常见断点之条件断点</h3><ol><li>触发：shirt+F2  </li><li>类似int3断点，只是要加条件断  </li><li>多条件用&amp;&amp;，|| 连接符  </li></ol><h3 id="内存一次性断点和条件记录断点"><a href="#内存一次性断点和条件记录断点" class="headerlink" title="内存一次性断点和条件记录断点"></a>内存一次性断点和条件记录断点</h3><ol><li>内存一次性断点：alt+m，断点原理是int3断点原理，但是只能用一次  </li><li>条件记录断点：shirt+F4，类似条件断点，但是alt+l可以查看断点位置特定寄存器等的值  </li></ol><h3 id="hit-trace-和-run-trace"><a href="#hit-trace-和-run-trace" class="headerlink" title="hit trace 和 run trace"></a>hit trace 和 run trace</h3><ol><li>原理 int3断点原理  </li><li>run trace 记录数据</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>密码类型及加密解密算法</title>
      <link href="/2021/120547052.html"/>
      <url>/2021/120547052.html</url>
      
        <content type="html"><![CDATA[<h2 id="现代密码"><a href="#现代密码" class="headerlink" title="现代密码"></a>现代密码</h2><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。就是明文加密和密文解密用的是同一种秘钥<br>例如:  </p><h4 id="rc4加密算法"><a href="#rc4加密算法" class="headerlink" title="rc4加密算法"></a>rc4加密算法</h4><ol><li>说明：rc4加密是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密，同时密钥的长度是可以变的，对于现在仍然有很强的保护性  </li><li>原理：根据明文和密钥生成相应的密钥流，密钥流的长度和明文的长度是对应的，也就是说明文的长度是500字节，那么密钥流也是500字节。当然，加密生成的密文也是500字节，因为密文第i字节=明文第i字节^密钥流第i字节。而生成密钥流需要用到状态向量（S），临时向量（T），密钥（K）即：  <ul><li>状态向量S：长度为256，S[0],S[1]…..S[255]。每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换  </li><li>临时向量T：长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T  </li><li>密钥K：长度为1-256字节，注意密钥的长度keylen与明文长度、密钥流的长度没有必然关系，通常密钥的长度趣味16字节（128比特）  <ul><li>初始化S和T<br>for i in range(256) :<br>s[i] = i<br>T[i]=Key[i%len(key)] (key是密钥)  </li><li>初始排列S<br>j = 0<br>for i in range(256) :<br>j = (j + s[i] + T[i]) % 256<br>s[i], s[j] = s[j], s[i]  </li><li>产生密钥流K<br>i = 0<br>j = 0<br>for r in range(len(message)) :<br>i = (i + 1) % 256<br>j = (j + s[i]) % 256<br>s[i], s[j] = s[j], s[i]<br>t = (S[i] + S[j]) % 256<br>K[t] = S[t] (K即是密钥流)  </li><li>脚本：  </li></ul></li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">def encrypt(tmp, message):      tmp &#x3D; list(map(lambda x: ord(x), tmp))      message &#x3D; list(map(lambda x: ord(x), message))       S &#x3D; list(range(0, 256))      key &#x3D; []  # 存储秘钥流      T &#x3D; []  # 临时向量T       while len(T) &lt; 256:          T.extend(tmp)      while len(T) !&#x3D; 256:          T.pop()       j &#x3D; 0      for i in range(0, 256):          j &#x3D; (j + S[i] + T[i]) % 256          S[i], S[j] &#x3D; S[j], S[i]       i, j &#x3D; 0, 0      for i in range(len(message)):          i &#x3D; (i + 1) % 256          j &#x3D; (j + S[i]) % 256          S[i], S[j] &#x3D; S[j], S[i]          t &#x3D; (S[i] + S[j]) % 256          key.append(S[t])       secretary &#x3D; list(map(lambda x, y: chr(x ^ y), message, key))      return secretary, key  def decrypt(secretary, key):      message &#x3D; list(map(lambda x, y: chr((ord(x)) ^ y), secretary, key))      return &#39;&#39;.join(message)  if __name__ &#x3D;&#x3D; &#39;__main__&#39;:      t &#x3D; list(input(&quot;请输入初始秘钥：&quot;))      m &#x3D; list(input(&quot;请输入需要加密的明文：&quot;))      s, k &#x3D; encrypt(t, m)      print(encrypt(t, m)) # t即为所求     print(&#39;经过加密解密后得到的明文：&#39;, decrypt(s, k))  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h4><ol><li>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：<br><img src="/2021/120547052/1.png" alt=" "><br>轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。上面说到，AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。   AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：<br> <img src="/2021/120547052/2.png" alt=" "><br> 其主要加密如下(10次加密图)：<br> <img src="/2021/120547052/3.png" alt=" "><br> 其中:  <ul><li>K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。  </li></ul></li></ol><ul><li><p>字节代换：<br>AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒。<br>AES的S盒：<br><img src="/2021/120547052/4.png" alt=" "><br>状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。<br>逆字节代换也就是查逆S盒来变换，逆S盒如下：<br><img src="/2021/120547052/5.png" alt=" ">  </p></li><li><p>行移位<br>行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节<br>行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节  </p></li><li><p>列混合<br>列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：<br><img src="/2021/120547052/6.png" alt=" "><br>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：<br><img src="/2021/120547052/7.png" alt=" "><br>其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。<br>逆向列混合变换可由下图的矩阵乘法定义：<br><img src="/2021/120547052/8.png" alt=" "></p></li><li><p>轮密钥加<br>轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算；轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。  </p></li><li><p>密钥扩展<br>AES首先将初始密钥输入到一个44的状态矩阵中，如下图所示。<br><img src="/2021/120547052/9.png" alt=" "><br>这个44矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为”abcdefghijklmnop”,则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生：1.如果i不是4的倍数，那么第i列由如下等式确定：W[i]=W[i-4]⨁W[i-1]2.如果i是4的倍数，那么第i列由如下等式确定：W[i]=W[i-4]⨁T(W[i-1])其中，T是一个有点复杂的函数。函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。a.字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。b.字节代换：对字循环的结果使用S盒进行字节代换。c.轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。轮常量Rcon[j]是一个字，其值见下表。<br><img src="/2021/120547052/10.png" alt=" ">  </p><pre><code>  ~~~          下面举个例子：          设初始的128位密钥为：          3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD          那么4个初始值为：          W[0] = 3C A1 0B 21          W[1] = 57 F0 19 16          W[2] = 90 2E 13 80          W[3] = AC C1 07 BD          下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。          由于4是4的倍数，所以：          W[4] = W[0] ⨁ T(W[3])          T(W[3])的计算步骤如下：          循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC;          将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91;          将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])=79 C5 7A 91，故          W[4] = 3C A1 0B 21 ⨁ 79 C5 7A 91 = 45 64 71 B0          其余的3个子密钥段的计算如下：          W[5] = W[1] ⨁ W[4] = 57 F0 19 16 ⨁ 45 64 71 B0 = 12 94 68 A6          W[6] = W[2] ⨁ W[5] =90 2E 13 80 ⨁ 12 94 68 A6 = 82 BA 7B 26          W[7] = W[3] ⨁ W[6] = AC C1 07 BD ⨁ 82 BA 7B 26 = 2E 7B 7C 9B          所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B    ~~~  </code></pre></li></ul><h4 id="TEA加密算法"><a href="#TEA加密算法" class="headerlink" title="TEA加密算法"></a>TEA加密算法</h4><ol><li><p>原理<br>TEA（Tiny Encryption Algorithm）是一种分组加密算法，它的实现非常简单，通常只需要很精短的几行代码。TEA算法使用64位的明文分组和128位的密钥，它使用Feistel分组加密框架，需要进行 64 轮迭代，尽管作者认为 32 轮已经足够了。该算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 0×9E3779B9）  </p></li><li><p>代码实现  </p><pre><code>  ~~~c      #include &lt;stdio.h&gt;      #include &lt;stdlib.h&gt;      #include &lt;Windows.h&gt;      void Encrypt(long* EntryData, long* Key)      &#123;          //分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组          unsigned long x = EntryData[0];          unsigned long y = EntryData[1];          unsigned long sum = 0;          unsigned long delta = 0x9E3779B9;          //总共加密32轮          for (int i = 0; i &lt; 32; i++)          &#123;              sum += delta;              x += ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);              y += ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);          &#125;          //最后加密的结果重新写入到数组中          EntryData[0] = x;          EntryData[1] = y;      &#125;      void Decrypt(long* EntryData, long* Key)      &#123;          //分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组          unsigned long x = EntryData[0];          unsigned long y = EntryData[1];          unsigned long sum = 0;          unsigned long delta = 0x9E3779B9;          sum = delta &lt;&lt; 5;   //注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.          //总共加密32轮 那么反序也解密32轮          for (int i = 0; i &lt; 32; i++)          &#123;              // 先将y解开 然后参与运算在解x              y -= ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);              x -= ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);              sum -= delta;          &#125;          //最后加密的结果重新写入到数组中          EntryData[0] = x;          EntryData[1] = y;      &#125;      int main()      &#123;</code></pre></li></ol><pre><code>            long Data[3] = &#123; 0x44434241,0x48474645,0x0 &#125;;            printf(&quot;待加密的数值 = %s\r\n&quot;, (char*)Data);            long key[4] = &#123; 0x11223344,0x55667788,0x99AABBCC,0xDDEEFF11 &#125;;            //Encrypt每次只是加密4字节数组中的两组(也就是每次加密8个字节) 如果你数据多.可以来个for循环来循环加密,但是Entrypt内部还有32次循环,所以速度上还是会有点影响.            Encrypt(Data, key);            printf(&quot;加密后的数值 = %s\r\n&quot;, (char*)Data);            Decrypt(Data, key);            printf(&quot;解密后的数值 = %s\r\n&quot;, (char*)Data);            system(&quot;pause&quot;);        &#125;      ~~~  </code></pre><h4 id="XTEA机密算法"><a href="#XTEA机密算法" class="headerlink" title="XTEA机密算法"></a>XTEA机密算法</h4><ol><li><p>原理<br>与TEA加密算法类似，只是增加了更多的密钥表，移位和异或操作等等。  </p></li><li><p>代码实现  </p><pre><code> ~~~c     #include &lt;stdio.h&gt;       #include &lt;stdint.h&gt;       void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;           unsigned int i;           uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;           for (i=0; i &lt; num_rounds; i++) &#123;               v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);               sum += delta;               v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);           &#125;           v[0]=v0; v[1]=v1;       &#125;            void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;           unsigned int i;           uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;           for (i=0; i &lt; num_rounds; i++) &#123;               v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);               sum -= delta;               v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);           &#125;           v[0]=v0; v[1]=v1;       &#125;            int main()       &#123;           uint32_t v[2]=&#123;1,2&#125;;           uint32_t const k[4]=&#123;2,2,3,4&#125;;           unsigned int r=32;//num_rounds建议取值为32           // v为要加密的数据是两个32位无符号整数           // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位           printf(&quot;加密前原始数据：%u %u\n&quot;,v[0],v[1]);           encipher(r, v, k);           printf(&quot;加密后的数据：%u %u\n&quot;,v[0],v[1]);           decipher(r, v, k);           printf(&quot;解密后的数据：%u %u\n&quot;,v[0],v[1]);           return 0;       &#125;   ~~~  </code></pre></li></ol><h4 id="XXTEA加密算法"><a href="#XXTEA加密算法" class="headerlink" title="XXTEA加密算法"></a>XXTEA加密算法</h4><ol><li><p>原理<br><img src="/2021/120547052/13.png" alt=" ">  </p></li><li><p>代码实现  </p><pre><code> ~~~c #include &lt;stdio.h&gt;   #include &lt;stdint.h&gt;   #define DELTA 0x9e3779b9   #define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))    void btea(uint32_t *v, int n, uint32_t const key[4])   &#123;       uint32_t y, z, sum;       unsigned p, rounds, e;       if (n &gt; 1)            /* Coding Part */       &#123;           rounds = 6 + 52/n;           sum = 0;           z = v[n-1];           do           &#123;               sum += DELTA;               e = (sum &gt;&gt; 2) &amp; 3;               for (p=0; p&lt;n-1; p++)               &#123;                   y = v[p+1];                   z = v[p] += MX;               &#125;               y = v[0];               z = v[n-1] += MX;           &#125;           while (--rounds);       &#125;       else if (n &lt; -1)      /* Decoding Part */       &#123;           n = -n;           rounds = 6 + 52/n;           sum = rounds*DELTA;           y = v[0];           do           &#123;               e = (sum &gt;&gt; 2) &amp; 3;               for (p=n-1; p&gt;0; p--)               &#123;                   z = v[p-1];                   y = v[p] -= MX;               &#125;               z = v[n-1];               y = v[0] -= MX;               sum -= DELTA;           &#125;           while (--rounds);       &#125;   &#125;     int main()   &#123;       uint32_t v[2]= &#123;1,2&#125;;       uint32_t const k[4]= &#123;2,2,3,4&#125;;       int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密       // v为要加密的数据是两个32位无符号整数       // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位       printf(&quot;加密前原始数据：%u %u\n&quot;,v[0],v[1]);       btea(v, n, k);       printf(&quot;加密后的数据：%u %u\n&quot;,v[0],v[1]);       btea(v, -n, k);       printf(&quot;解密后的数据：%u %u\n&quot;,v[0],v[1]);       return 0;   &#125;   ~~~  </code></pre></li></ol><h2 id="其他密码学"><a href="#其他密码学" class="headerlink" title="其他密码学"></a>其他密码学</h2><h3 id="base加密"><a href="#base加密" class="headerlink" title="base加密"></a>base加密</h3><ol><li><p>原理<br>a. 将三个八位的字节转化为四个六位的字节，不足补零。它是用64个可打印字符表示二进制所有数据方法。由于2的6次方等于64，所以可以用每6个位元为一个单元，对应某个可打印字符。我们知道三个字节有24个位元，就可以刚好对应于4个Base64单元，即3个字节需要用4个Base64的可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9 ，这样共有62个字符，此外两个可打印符号在不同的系统中一般有所不同。但是，我们经常所说的Base64另外2个字符是：“+/”。这64个字符，所对应的索引表如下(索引号不是对应的ascii值)：<br><img src="/2021/120547052/11.png" alt=" "><br>b. 转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。所以加密后的数据量是原来的4/3。<br>c. 但转换的字节数不一定就是24的整数倍，会出现有多余不足六位的情况，在base64中处理的方法是加零凑够六位，但是这样一来在解码的时候就会出现多余的位，这该怎么办呢？ 不用担心，base64想到了一个很好的解决办法。<br>​d. 这个办法就是在base64凑零的同时，还要满足凑出来的位数是8的倍数，不然就加一个或者两个特殊的六位=符号。为什么是一个或者两个=符号呢？因为多个8位转为6位 只会出现剩余2位、4位的情况，剩余2位时只需要一个表示六位的=便可变为8的整数；而剩余4位 需要两个表示6位的=便可以变为8的整数。然后在解密的时候不解析=即可。<br>​之所以位的总数需要凑成8的倍数，是因为base64主要用于加密后的数据传送，而在传送机制中都认为传送的最小单位是按照字节算的，所以不能出现不是位总数不是8的倍数的情况，在接收到数据后，按顺序将6位的base64直接按照顺序解密成字节就完成解密了。<br><img src="/2021/120547052/12.png" alt=" ">  </p></li><li><p>base加密系列字母表  </p></li><li><p><strong>base16：0到9，A到F<a href="https://www.qqxiuzi.cn/bianma/base.php?type=16">在线解密</a></strong>  </p></li><li><p><strong>base32：A到Z，2到7<a href="https://www.qqxiuzi.cn/bianma/base.php">在线解密</a></strong>  </p></li><li><p>base36：0到9，a到z<a href="http://ctf.ssleye.com/base36w.html">在线解密</a>  </p></li><li><p><strong>base58:1到9，a到z，A到Z<a href="http://www.metools.info/code/c74.html">在线解密</a></strong>  </p></li><li><p><strong>base62:0到9，a到z，A到Z<a href="http://www.atoolbox.net/Tool.php?Id=933">在线解密</a></strong>  </p></li><li><p><strong>base64:a到z，A到Z，0到9，特别地有/+（可以转图片）<a href="https://tool.oschina.net/encrypt?type=3">在线解密</a></strong>  </p></li><li><p><strong>base91：A到Z，a到z，0到9，!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`{|}~）<a href="http://www.atoolbox.net/Tool.php?Id=935">在线解密</a></strong>  </p></li><li><p><strong>base92：0到9，A到Z，a到z，!#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_{|｝<a href="http://ctf.ssleye.com/base92.html">在线解密</a></strong>  </p></li><li><p><strong>base128：0到9，A到Z，a到z，\xb5\xb6\xb7\xbc\xbd\xbe\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff</strong>  </p></li><li><p>代码待补充  </p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向题</title>
      <link href="/2021/120454815.html"/>
      <url>/2021/120454815.html</url>
      
        <content type="html"><![CDATA[<h1 id="逆向题"><a href="#逆向题" class="headerlink" title="逆向题"></a>逆向题</h1><ol><li>招新时期的题:haha.exe  <ul><li>首先，这道题放入Exeinfo PE中查看这道题的简单情况如下:<br><img src="/2021/120454815/1.png"><br>在这几个界面，首先 1 的位置显示的是文件的名称；2 的位置显示的是文件信息，如果加壳会显示是什么壳；3 的位置显示的文件是32位还是64位，便于分析；4 的位置显示的是编写这个文件使用的哪种语言；5 中最开始显示是否带壳；之后提示打开文件可以运用的文件  </li><li>其次，haha.exe这个文件是一个可运行的程序，但是当你打开输入信息的时候会自动闪退，放入32位ida的时候可以看到该main()函数的地址一致会变化，这也是程序打开闪退的原因，针对这个问题，可以使用 studyPE 这个软件来固定基址，从而解决闪退的问题。  </li><li>再一，文件打开之后，F5显示伪代码(语法神似c语言)，这时候根据之前文件的正常运行，会将含有flag信息的代码信息直接跳过，例如:<br><img src="/2021/120454815/2.png">类似上图一样，涵盖flag的信息全没有  </li><li>再二，返回初始界面，根据流程图进行分析<br><img src="/2021/120454815/3.png"><br>分析可以知道在004012F4位置原来有一个跳转，上面那个语法会满足跳转条件，从而让我们想要的信息被跳过，所以这时候我们需要将它nop掉来阻止跳转，结果如图  </li><li>再三，在进行上述操作之后，可以再次找到main(),F5显示伪代码，这个时候就可以分析了，看下图<br><img src="/2021/120454815/4.png"><br>在这个图里分析可以看到，输入 1 会得到一个flag.doc文件，2走迷宫，3退出，同时分析知flag.doc打开之后要密码，即我们要走迷宫，然后分析到sub_401120()这里，点开如下<br><img src="/2021/120454815/6.png"><br>在这里可以看到用wasd走迷宫，同时分析知迷宫格式在V5=dword_403300[v4 + v2]这里，之后走迷宫即可，之后得到的字符串需要在LABEL_15地址进行异或操作，得到真正的密码字符串  </li><li>最后，如下图<br><img src="/2021/120454815/7.png"><br>最后flag改为henu，同时注意最好以命令行的形式打开.exe文件，不然还是会出现闪退的问题(这个应该不是基址的问题了)  </li><li>总结：<br>关键点:固定基址，除掉跳转(nop),程序打开方式</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向常见壳</title>
      <link href="/2021/120329596.html"/>
      <url>/2021/120329596.html</url>
      
        <content type="html"><![CDATA[<p>#逆向常见壳  </p><ol><li>加壳目的  <ul><li>隐藏文件作者的个人信息或者相关不应该暴露的信息  </li><li>压缩文件，加壳之后文件的体积会变小  </li><li>有些黑客会使用壳来防止自己在文件中加入的病毒等东西被杀毒软件找到杀掉  </li></ul></li><li>常见壳的类型  <ul><li>压缩壳  </li><li>保护壳  </li><li>捆绑壳  </li></ul></li><li>压缩壳  <ul><li>upx加壳或脱壳  <ul><li>加壳原理: 首先将程序压缩。所谓的压缩包括两方面，一方面在程序的开头或者其他合适的地方 插入一段代码，另一方面是将程序的其他地方做压缩。压缩也可以叫做加密，因为压缩后的程序比较难看懂，主要是 和原来的代码有很大的不同。最大的表现也就是他的主要作用就是程序本身变小了。变小之后的程序在传输方面有很 大的优势。其次就是在程序执行时，实时的对程序解压缩  </li><li>加壳格式:<br>最初代码的形式就应该是:7==&gt;8==&gt;9==&gt;5==&gt;6<br>用upx压缩之后形式为：1==&gt;2==&gt;3==&gt;4==&gt;5==&gt;6<br>执行时的形式变为：1==&gt;7==&gt;8==&gt;9==&gt;5==&gt;6(其中1是upx插入的代码，2,3,4是文件代码,5,6随意)  </li><li>加壳解壳工具:<br>加壳：upx shell，也可以下载upx，在命令行中该目录下使用命令:upx 文件名 进行加壳操作<br>解壳：upx unpacker，也可以也可以下载upx，在命令行中该目录下使用命令:upx -d 文件名 进行解壳操作(我常用方式)，也可以进行手动解壳(太难，不建议使用，如果是大佬请忽略)  </li><li>示例：<br>upx加壳操作<br><img src="/2021/120329596/1.png"><br>upx解壳操作<br><img src="/2021/120329596/2.png"><br>手动解壳(待补充!!!)<br><a href="https://upx.github.io/">upx下载地址</a>  </li></ul></li><li>ASPack壳  <ul><li>ASPack壳也是压缩壳，加壳原理与upx相同  </li><li>加壳解壳工具:<br>加壳:ASPack<br>解壳:ASPack UnPacker  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>PECompact壳  <ul><li>PECompact壳也是压缩壳，加壳原理与upx相同  </li><li>加壳解壳工具:<br>加壳:PECompact_v3.02.2_Final.7z<br>解壳:Unpacker_PECompact.7z  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>RLPack壳  <ul><li>RLPack壳也是压缩壳，加壳原理与upx相同  </li><li>加壳解壳工具:<br>加壳:()<br>解壳:Rlpack 1.2x_Unpacker_V0.3_Final.rar  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>NsPack壳  <ul><li>NsPack壳也是压缩壳，加壳原理与upx相同  </li><li>加壳解壳工具:<br>加壳:NsPack<br>解壳:NsPack strripter 3.x  </li><li>示例:(未遇到，待补充)  </li></ul></li></ul></li><li>保护壳  <ul><li>ASProtect壳    <ul><li>加壳解壳工具:<br>加壳:ASProtect.SKE.v2.51.build.09.22.beta-RES-incl-kg.7z<br>解壳:ASProtect Unpacker.rar  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>Armadillo壳    <ul><li>加壳解壳工具:<br>加壳:<br>解壳:  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>EXECryptor壳    <ul><li>加壳解壳工具:<br>加壳:()<br>解壳:Unpacker ExeCryptor 2.x.x v1.0 RC2.zip  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>Themida壳    <ul><li>加壳解壳工具:<br>加壳:Themida_x32_x64_v3.0.4.0_Repacked.rar<br>解壳:Themida&amp;winlicense UnPacKer v2.0.rar  </li><li>示例:(未遇到，待补充)   </li></ul></li><li>VMProtect壳    <ul><li>加壳解壳工具:<br>VMProtect_Professional_v2.13.8.rar  </li><li>示例:(未遇到，待补充)   </li></ul></li></ul></li><li>捆绑壳  <ul><li>MoleBox壳  <ul><li>加壳解壳工具:<br>加壳:<br>解壳: Molebox_Virtualization_Studio_unpacker </li><li>示例:(未遇到，待补充)   </li></ul></li></ul></li><li>补充说明:<br> <a href="https://www.52pojie.cn/">以上部分加壳解壳工具下载地址</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向中的一些基础</title>
      <link href="/2021/112836631.html"/>
      <url>/2021/112836631.html</url>
      
        <content type="html"><![CDATA[<p>#函数  </p><ol><li>strcmp()函数  <ul><li>strcmp()函数采用两个char数组或字符串参数<br>格式：int strcmp (const char* str1, const char* str2)：第一个字符串或char数组，将与第二个字符串或char数组进行比较。 const主要用于防止更改给定的char数组指针。</li><li>返回值：str1&gt;str2–&gt;正整数;str1 &lt; str2 –&gt;负整数;str1 = str2 –&gt;0 </li><li>例如  </li></ul></li><li>char str1[] = “abcd”, str2[] = “aBcd”：第一个字符串较大，并返回一个正整数，该整数是字符的值;第二个字符串较大，并返回一个负整数，该整数是字符的值；相同则会返回0。  </li><li>!strcmp(s, enflag)：比较s和enflag的字符串，相同就符合条件。</li><li>chr()函数  <ul><li>chr()函数从指定ASCII码返回字符  </li><li>ASCII值可以为十进制值,八进制值(前置加0),十六进制值(前置加0x)。  </li></ul></li><li>strlen函数  <ul><li>格式：size_t strlen( const char *string )  </li><li>返回值是类型是size_t类型(长度)，strlen是不会计算\0的长度的，strlen函数遇到\0就会停止下来。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/112316107.html"/>
      <url>/2021/112316107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
