<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubernetes</title>
      <link href="/2022/080211340.html"/>
      <url>/2022/080211340.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Kubernetes介绍"><a href="#1-Kubernetes介绍" class="headerlink" title="1. Kubernetes介绍"></a>1. Kubernetes介绍</h1><h2 id="1-1-应用部署方式演变"><a href="#1-1-应用部署方式演变" class="headerlink" title="1.1 应用部署方式演变"></a>1.1 应用部署方式演变</h2><p>在部署应用程序的方式上，主要经历了三个时代：</p><ul><li><p>传统部署：互联网早期，会直接将应用程序部署在物理机上</p><blockquote><p>优点：简单，不需要其它技术的参与</p><p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p></blockquote></li><li><p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p><blockquote><p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p><p>缺点：增加了操作系统，浪费了部分资源</p></blockquote></li><li><p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p><blockquote><p>优点：</p><p>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p><p>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p><p>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p></blockquote></li></ul><p><img src="/2022/080211340/1.png" alt=" ">  </p><p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p><ul><li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li><li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li></ul><p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p><ul><li><strong>Swarm</strong>：Docker自己的容器编排工具</li><li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li><li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li></ul><p><img src="/2022/080211340/image-20200524150339551.png" alt="image-20200524150339551">  </p><h2 id="1-2-kubernetes简介"><a href="#1-2-kubernetes简介" class="headerlink" title="1.2 kubernetes简介"></a>1.2 kubernetes简介</h2><p><img src="/2022/080211340/image-20200406232838722.png" alt="image-20200406232838722"></p><p>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器—-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p><p>kubernetes的本质是<strong>一组服务器集群</strong>，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p><ul><li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li><li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li><li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li><li><strong>负载均衡</strong>：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li><li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li><li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li></ul><p><img src="/2022/080211340/image-20200526203726071-1626780706899.png" alt="image-20200526203726071"></p><h2 id="1-3-kubernetes组件"><a href="#1-3-kubernetes组件" class="headerlink" title="1.3 kubernetes组件"></a>1.3 kubernetes组件</h2><p>一个kubernetes集群主要是由**控制节点(master)<strong>、</strong>工作节点(node)**构成，每个节点上都会安装不同的组件。</p><p><strong>master：集群的控制平面，负责集群的决策 ( 管理 )</strong></p><blockquote><p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p><p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p><p><strong>ControllerManager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p><p><strong>Etcd</strong> ：负责存储集群中各种资源对象的信息</p></blockquote><p><strong>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</strong></p><blockquote><p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p><p><strong>KubeProxy</strong> : 负责提供集群内部的服务发现和负载均衡</p><p><strong>Docker</strong> : 负责节点上容器的各种操作</p></blockquote><p><img src="/2022/080211340/image-20200406184656917.png" alt="image-20200406184656917"></p><p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p><ol><li><p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</p></li><li><p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</p></li><li><p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上</p><p>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</p></li><li><p>apiServer调用controller-manager去调度Node节点安装nginx服务</p></li><li><p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod</p><p>pod是kubernetes的最小操作单元，容器必须跑在pod中至此，</p></li><li><p>一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理</p></li></ol><p>这样，外界用户就可以访问集群中的nginx服务了  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LLVM-Clang编译器安装和使用</title>
      <link href="/2022/031262045.html"/>
      <url>/2022/031262045.html</url>
      
        <content type="html"><![CDATA[<p>转载于：<a href="L1uis1'sblog">L1uis1’sblog</a></p><article class="post-content" id="article-container"><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><ol><li>apt-get install clang</li></ol></blockquote><blockquote><ol start="2"><li>apt-get install llvm</li></ol></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="LLVM-IR文件"><a href="#LLVM-IR文件" class="headerlink" title="LLVM IR文件"></a>LLVM IR文件</h2><ol><li><p>使用clang将C源码转换为LLVM IR(文本形式)：</p><blockquote><p>clang -emit-llvm -S test.c -o test.ll / clang -O3 -emit-llvm test.c -S -o test.ll</p></blockquote></li><li><p>使用clang将C源码转换为LLVM IR(二进制形式)：</p><blockquote><p>clang -emit-llvm test.c -c -o test.bc / clang -O3 -emit-llvm test.c -c -o test.bc</p></blockquote></li><li><p>LLVM IR文件格式转换(.bc和.ll文件的转换)</p><blockquote><p>llvm-as test.ll -o test.bc     //llvm .ll -&gt; .bc assembler<br>llvm-dis test.bc -o test.ll  //llvm .bc -&gt; .ll disassembler</p></blockquote></li><li><p>将LLVM字节码转换为机器汇编码</p><blockquote><p>llc test.bc -o test.s</p></blockquote></li><li><p>由LLVM IR生成对应的可执行文件</p><blockquote><p>llc -filetype=obj test.ll -o test.o<br>gcc test.o<br>或者<br>llc -filetype=obj test.bc -o test.o<br>gcc test.o</p></blockquote></li></ol><p>注：生成可执行文件时，若出现如下或类似的报错</p><figure class="highlight bash"><div class="highlight-tools "><i class="fas fa-angle-down expand "></i><div class="code-lang">bash</div><div class="copy-notice"></div><i class="fas fa-paste copy-button"></i></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: test.o: relocation R_X86_64_32 against symbol `what<span class="string">' can not be used when making a PIE object; recompile with -fPIE</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br></pre></td></tr></tbody></table></figure><p>使用</p><blockquote><p>clang++  test.o -o test</p></blockquote></article>  ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python逆向</title>
      <link href="/2022/030533794.html"/>
      <url>/2022/030533794.html</url>
      
        <content type="html"><![CDATA[<h1 id="python逆向"><a href="#python逆向" class="headerlink" title="python逆向"></a>python逆向</h1><h2 id="附件为py文件"><a href="#附件为py文件" class="headerlink" title="附件为py文件"></a>附件为py文件</h2><p>直接看源代码分析</p><h2 id="附件为pyc文件"><a href="#附件为pyc文件" class="headerlink" title="附件为pyc文件"></a>附件为pyc文件</h2><ul><li>在线网址反编译：<a href="https://tool.lu/pyc/">python反编译 - 在线工具 (tool.lu)</a></li><li>使用uncompyle6<ul><li>安装：pip install uncompyle6</li><li>使用：uncompyle6 -o test.py test.pyc</li></ul></li></ul><h2 id="附件为打包的exe文件"><a href="#附件为打包的exe文件" class="headerlink" title="附件为打包的exe文件"></a>附件为打包的exe文件</h2><ul><li>使用Pyinstaller打包<ul><li>安装：<a href="https://sourceforge.net/projects/pyinstallerextractor/">PyInstaller Extractor download | SourceForge.net</a></li><li>使用：python pyinstxtractor.py test.exe</li></ul></li><li>使用py2exe打包<ul><li>安装unpy2exe：pip install unpy2exe</li><li>使用：unpy2exe.py -o test test.exe</li></ul></li></ul><h2 id="python字节码"><a href="#python字节码" class="headerlink" title="python字节码"></a>python字节码</h2><p>根据官方文档慢慢翻译</p><p><a href="https://docs.python.org/zh-cn/3/library/dis.html?highlight=dis">dis — Python 字节码反汇编器 — Python 3.10.1 文档</a>  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>花指令及迷宫问题</title>
      <link href="/2022/03051961.html"/>
      <url>/2022/03051961.html</url>
      
        <content type="html"><![CDATA[<h1 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h1><h2 id="什么是花指令"><a href="#什么是花指令" class="headerlink" title="什么是花指令"></a>什么是花指令</h2><p>​花指令实质就是一串垃圾指令，它与程序本身的功能无关，并不影响程序本身的逻辑。在软件保护中，花指令被作为一种手段来增加静态分析的难度，花指令也可以被用在病毒或木马上，通过加入花指令改变程序的特征码，躲避杀软的扫描，从而达到免杀的目的，本文将介绍一些常见的花指令的形式，花指令一般被分为两类，被执行的和不会被执行的。</p><p>​花指令是企图隐藏掉不想被逆向工程的代码块 (或其它功能) 的一种方法, 在真实代码中插入一些垃圾代码的同时还保证原有程序的正确执行, 而程序无法很好地反编译, 难以理解程序内容, 达到混淆视听的效果.</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>产生花指令的根本原因是x86指令集由不定长指令构成<br>当通过跳转使执行流命中到另一条指令的中间时就会造成静态反汇编的解析错误</p><p>现代反汇编器有两种思路：</p><p>线性扫描<br>从开头到结尾依次读取机器码并进行反汇编<br>递归下降<br>从程序入口向后反汇编，遇到条件跳转则分别从分支的地方继续反汇编，无条件跳转则尝试从目的指令继续反汇编<br>线性扫描显然很容易制造花指令，只要在跳转和目标之间插入长度较长的指令开头（例如E8，后接4个字节）即可使之后的所有指令解析错误。OllyDbg和windbg就是使用的线性扫描法</p><p>而递归下降则可以避开这种简单的花指令，跳过中间的脏字节。但对于一些针对性的花指令–例如jz+jnz+脏字节，则会由于上下文无关的算法而对脏字节进行解析</p><p>除此以外还有把call当jmp使用的手段，由于在编译器中call只会用来作为子程序/函数跳转的指令，因此IDA往往会将call的地址视作一个函数的起始地址，进而破坏整个函数的完整性</p><h2 id="常见花指令"><a href="#常见花指令" class="headerlink" title="常见花指令"></a>常见花指令</h2><ol><li><p>jx+jnx</p></li><li><p>call+pop/add esp/add [esp] + retn</p></li><li><p>stx/jx</p></li><li><p>循环跳转花指令  </p></li></ol><h2 id="如何去除花指令"><a href="#如何去除花指令" class="headerlink" title="如何去除花指令"></a>如何去除花指令</h2><p>   根据程序需要修改或者nop掉，具体问题具体分析  </p><h1 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h1><p>迷宫问题有以下特点:</p><ul><li>在内存中布置一张 “地图”</li><li>将用户输入限制在少数几个字符范围内.</li><li>一般只有一个迷宫入口和一个迷宫出口</li></ul><p>​布置的地图可以由可显字符 (比如<code>#</code>和<code>*</code>)组合而成 (这非常明显, 查看字符串基本就知道这是个迷宫题了.), 也可以单纯用不可显的十六进制值进行表示. 可以将地图直接组成一条非常长的字符串, 或是一行一行分开布置. 如果是一行一行分开布置的话, 因为迷宫一般都会比较大, 所以用于按行(注意, 布置并非按顺序布置, 每行都对应一个具体的行号, 你需要确定行号才能还原迷宫地图) 布置迷宫的函数会明显重复多次.</p><p>​而被限制的字符通常会是一些方便记忆的组合 (不是也没办法), 比如<code>w/s/a/d</code>, <code>h/j/k/l</code>, <code>l/r/u/d</code>这样的类似组合. 当然各个键具体的操作需要经过分析判断 (像那种只用一条字符串表示迷宫的, 就可以用<code>t</code>键表示向右移动<code>12</code>个字符这样). 对于二维的地图, 一般作者都会设置一个<code>X坐标</code>和一个<code>Y坐标</code>用于保存当前位置. 我们也可以根据这个特点来入手分析.</p><p>​一般情况下, 迷宫是只有 1 个入口和 1 个出口, 像入口在最左上角<code>(0, 0)</code>位置, 而出口在最右下角<code>(max_X, max_Y)</code>处. 但也有可能是出口在迷宫的正中心, 用一个<code>Y</code>字符表示等等. 解答迷宫题的条件也是需要根据具体情况判断的.</p><p>​当然迷宫的走法可能不止 1 条, 也有情况是有多条走法, 但是要求某一个走法比如说代价最小. 那么这就可以变相为一个算法问题.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>od使用</title>
      <link href="/2022/011152450.html"/>
      <url>/2022/011152450.html</url>
      
        <content type="html"><![CDATA[<h2 id="od部分原理"><a href="#od部分原理" class="headerlink" title="od部分原理"></a>od部分原理</h2><h3 id="常见断点之INT3断点原理"><a href="#常见断点之INT3断点原理" class="headerlink" title="常见断点之INT3断点原理"></a>常见断点之INT3断点原理</h3><ol><li>原理<br>F2断点又叫做CC断点（INT3）断点。<br>01 替换指令，也就是替换int3指令<br>02 od检测到int3指令之后会产生一个异常处理并捕获它，这时候程序就会中断<br>03 od删除int3指令，还原之前代码  </li><li>优点<br>可以无限下int3断点  </li><li>缺点<br>太容易被检测到  </li></ol><h3 id="INT3断点的反调试与反反调试"><a href="#INT3断点的反调试与反反调试" class="headerlink" title="INT3断点的反调试与反反调试"></a>INT3断点的反调试与反反调试</h3><ol><li><p>知识点<br>01 FARPROC结构体<br>02 GetprocAddress()函数:检索指定的动态链接库(DLL)中的输出库函数地址。<br>03 LoadLibrary()函数:将指定的模块加载到调用进程的地址空间中。指定的模块可能会导致其他模块被加载。对于其他加载选项，请使用 LoadLibraryEx函数。  </p></li><li><p>函数原型<br>GetprocAddress()函数原型：</p><pre><code class="c"> FARPROC GetProcAddress(       HMODULE   hModule,    // DLL模块句柄       LPCSTR       lpProcName   // 函数名   );  </code></pre></li><li><p>代码  </p><pre><code class="c"> #include &lt;iostream&gt; #include &lt;Windows.h&gt; int main() &#123;     FARPROC addr = GetProcAddress(LoadLibrary(L&quot;user32.dll&quot;), &quot;MessageBoxA&quot;);     byte byteAdder = *(byte*)addr;     ::MessageBoxA(NULL, &quot;内容&quot;, &quot;标题&quot;, MB_OK);//调用MessageBoxA()     if (byteAdder == 0xCC) &#123;         printf(&quot;检测到非法调试&quot;);     &#125;     else &#123;         printf(&quot;程序正常运行&quot;);     &#125;     getchar(); &#125;  </code></pre></li><li><p>反调试<br>未进行调试时:<br><img src="/2022/011152450/1.png" alt=" "><br>对MessageBoxA()进行下断点:<br><img src="/2022/011152450/2.png" alt=" ">  </p></li><li><p>反反调试<br>在MessageBoxA()下面一行代码下INT3断点<br><img src="/2022/011152450/3.png" alt=" "><br><img src="/2022/011152450/1.png" alt=" ">  </p></li></ol><h3 id="常用断点之硬件断点"><a href="#常用断点之硬件断点" class="headerlink" title="常用断点之硬件断点"></a>常用断点之硬件断点</h3><ol><li>调试寄存器<br>DR0–DR7<br>DR0–DR3 :保存断点地址 ;DR4–DR5 ;DR6 :状态寄存器 ;DR7 :控制寄存器  </li><li>原理<br>DR0–DR3 :保存下硬件断点的地址<br>DR7 :设置相对应的控制位<br>当运行到此位置是会发送一个异常信息，导致程序中断，等待用户操作  </li><li>优点 ：不易被检测，速度快<br>缺点 : 只能下四个断点  </li></ol><h3 id="常用断点之内存断点"><a href="#常用断点之内存断点" class="headerlink" title="常用断点之内存断点"></a>常用断点之内存断点</h3><ol><li>原理<br>在该位置下内存断点，导致该位置赋予不可读、不可写、不可执行的属性，从而运行到此处时发送异常，导致程序中断。  </li><li>优点：不改变汇编代码<br>缺点：无  </li></ol><h3 id="常见断点之消息断点"><a href="#常见断点之消息断点" class="headerlink" title="常见断点之消息断点"></a>常见断点之消息断点</h3><ol><li>原理<br>当点击或者处理一个事件时，会形成消息，想内核发送，内核进行识别并做出相应的处理  </li></ol><h3 id="常见断点之条件断点"><a href="#常见断点之条件断点" class="headerlink" title="常见断点之条件断点"></a>常见断点之条件断点</h3><ol><li>触发：shirt+F2  </li><li>类似int3断点，只是要加条件断  </li><li>多条件用&amp;&amp;，|| 连接符  </li></ol><h3 id="内存一次性断点和条件记录断点"><a href="#内存一次性断点和条件记录断点" class="headerlink" title="内存一次性断点和条件记录断点"></a>内存一次性断点和条件记录断点</h3><ol><li>内存一次性断点：alt+m，断点原理是int3断点原理，但是只能用一次  </li><li>条件记录断点：shirt+F4，类似条件断点，但是alt+l可以查看断点位置特定寄存器等的值  </li></ol><h3 id="hit-trace-和-run-trace"><a href="#hit-trace-和-run-trace" class="headerlink" title="hit trace 和 run trace"></a>hit trace 和 run trace</h3><ol><li>原理 int3断点原理  </li><li>run trace 记录数据</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>密码类型及加密解密算法</title>
      <link href="/2021/120547052.html"/>
      <url>/2021/120547052.html</url>
      
        <content type="html"><![CDATA[<h2 id="现代密码"><a href="#现代密码" class="headerlink" title="现代密码"></a>现代密码</h2><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。就是明文加密和密文解密用的是同一种秘钥<br>例如:  </p><h4 id="rc4加密算法"><a href="#rc4加密算法" class="headerlink" title="rc4加密算法"></a>rc4加密算法</h4><ol><li>说明：rc4加密是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密，同时密钥的长度是可以变的，对于现在仍然有很强的保护性  </li><li>原理：根据明文和密钥生成相应的密钥流，密钥流的长度和明文的长度是对应的，也就是说明文的长度是500字节，那么密钥流也是500字节。当然，加密生成的密文也是500字节，因为密文第i字节=明文第i字节^密钥流第i字节。而生成密钥流需要用到状态向量（S），临时向量（T），密钥（K）即：  <ul><li>状态向量S：长度为256，S[0],S[1]…..S[255]。每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换  </li><li>临时向量T：长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T  </li><li>密钥K：长度为1-256字节，注意密钥的长度keylen与明文长度、密钥流的长度没有必然关系，通常密钥的长度趣味16字节（128比特）  <ul><li>初始化S和T<br>for i in range(256) :<br>s[i] = i<br>T[i]=Key[i%len(key)] (key是密钥)  </li><li>初始排列S<br>j = 0<br>for i in range(256) :<br>j = (j + s[i] + T[i]) % 256<br>s[i], s[j] = s[j], s[i]  </li><li>产生密钥流K<br>i = 0<br>j = 0<br>for r in range(len(message)) :<br>i = (i + 1) % 256<br>j = (j + s[i]) % 256<br>s[i], s[j] = s[j], s[i]<br>t = (S[i] + S[j]) % 256<br>K[t] = S[t] (K即是密钥流)  </li><li>脚本：  </li></ul></li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">def encrypt(tmp, message):      tmp &#x3D; list(map(lambda x: ord(x), tmp))      message &#x3D; list(map(lambda x: ord(x), message))       S &#x3D; list(range(0, 256))      key &#x3D; []  # 存储秘钥流      T &#x3D; []  # 临时向量T       while len(T) &lt; 256:          T.extend(tmp)      while len(T) !&#x3D; 256:          T.pop()       j &#x3D; 0      for i in range(0, 256):          j &#x3D; (j + S[i] + T[i]) % 256          S[i], S[j] &#x3D; S[j], S[i]       i, j &#x3D; 0, 0      for i in range(len(message)):          i &#x3D; (i + 1) % 256          j &#x3D; (j + S[i]) % 256          S[i], S[j] &#x3D; S[j], S[i]          t &#x3D; (S[i] + S[j]) % 256          key.append(S[t])       secretary &#x3D; list(map(lambda x, y: chr(x ^ y), message, key))      return secretary, key  def decrypt(secretary, key):      message &#x3D; list(map(lambda x, y: chr((ord(x)) ^ y), secretary, key))      return &#39;&#39;.join(message)  if __name__ &#x3D;&#x3D; &#39;__main__&#39;:      t &#x3D; list(input(&quot;请输入初始秘钥：&quot;))      m &#x3D; list(input(&quot;请输入需要加密的明文：&quot;))      s, k &#x3D; encrypt(t, m)      print(encrypt(t, m)) # t即为所求     print(&#39;经过加密解密后得到的明文：&#39;, decrypt(s, k))  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h4><ol><li>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：<br><img src="/2021/120547052/1.png" alt=" "><br>轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。上面说到，AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。   AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：<br> <img src="/2021/120547052/2.png" alt=" "><br> 其主要加密如下(10次加密图)：<br> <img src="/2021/120547052/3.png" alt=" "><br> 其中:  <ul><li>K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。  </li></ul></li></ol><ul><li>字节代换：  </li></ul><ol><li><p>AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒。<br>AES的S盒：<br><img src="/2021/120547052/4.png" alt=" "><br>状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。<br>逆字节代换也就是查逆S盒来变换，逆S盒如下：<br><img src="/2021/120547052/5.png" alt=" ">  </p></li><li><p>计算方式进行字节代换<br>AES算法中定义的加法和乘法<br>加法：两个字节相加，其和为两个字节按比特异或的结果<br>乘法：两个字节相乘，其积为对应多项式的乘积模二元域GF(2)上的8次不可约多项式m(x)==x^8⊕x^4⊕x^3⊕x⊕1后的结果所对应的字节<br>例如：<br><img src="/2021/120547052/47.png" alt=" "><br>再者<br><img src="/2021/120547052/48.png" alt=" ">  </p></li></ol><ul><li>行移位<br>行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节<br>行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节  </li><li>列混合<br>列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：<br><img src="/2021/120547052/6.png" alt=" "><br>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：<br><img src="/2021/120547052/7.png" alt=" "><br>其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。<br>逆向列混合变换可由下图的矩阵乘法定义：<br><img src="/2021/120547052/8.png" alt=" "></li><li>轮密钥加<br>轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算；轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。  </li><li>密钥扩展<br>AES首先将初始密钥输入到一个44的状态矩阵中，如下图所示。<br><img src="/2021/120547052/9.png" alt=" "><br>这个44矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为”abcdefghijklmnop”,则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生：1.如果i不是4的倍数，那么第i列由如下等式确定：W[i]=W[i-4]⨁W[i-1]2.如果i是4的倍数，那么第i列由如下等式确定：W[i]=W[i-4]⨁T(W[i-1])其中，T是一个有点复杂的函数。函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。a.字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。b.字节代换：对字循环的结果使用S盒进行字节代换。c.轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。轮常量Rcon[j]是一个字，其值见下表。<br><img src="/2021/120547052/10.png" alt=" ">  </li></ul><pre class="line-numbers language-none"><code class="language-none">下面举个例子：设初始的128位密钥为：3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD那么4个初始值为：W[0] &#x3D; 3C A1 0B 21W[1] &#x3D; 57 F0 19 16W[2] &#x3D; 90 2E 13 80W[3] &#x3D; AC C1 07 BD下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。由于4是4的倍数，所以：W[4] &#x3D; W[0] ⨁ T(W[3])T(W[3])的计算步骤如下：循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC;将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91;将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])&#x3D;79 C5 7A 91，故W[4] &#x3D; 3C A1 0B 21 ⨁ 79 C5 7A 91 &#x3D; 45 64 71 B0其余的3个子密钥段的计算如下：W[5] &#x3D; W[1] ⨁ W[4] &#x3D; 57 F0 19 16 ⨁ 45 64 71 B0 &#x3D; 12 94 68 A6W[6] &#x3D; W[2] ⨁ W[5] &#x3D;90 2E 13 80 ⨁ 12 94 68 A6 &#x3D; 82 BA 7B 26W[7] &#x3D; W[3] ⨁ W[6] &#x3D; AC C1 07 BD ⨁ 82 BA 7B 26 &#x3D; 2E 7B 7C 9B所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="TEA加密算法"><a href="#TEA加密算法" class="headerlink" title="TEA加密算法"></a>TEA加密算法</h4><ol><li>原理<br>TEA（Tiny Encryption Algorithm）是一种分组加密算法，它的实现非常简单，通常只需要很精短的几行代码。TEA算法使用64位的明文分组和128位的密钥，它使用Feistel分组加密框架，需要进行 64 轮迭代，尽管作者认为 32 轮已经足够了。该算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 0×9E3779B9）  </li><li>代码实现  </li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;void Encrypt(long* EntryData, long* Key)&#123;    &#x2F;&#x2F;分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组    unsigned long x &#x3D; EntryData[0];    unsigned long y &#x3D; EntryData[1];    unsigned long sum &#x3D; 0;    unsigned long delta &#x3D; 0x9E3779B9;    &#x2F;&#x2F;总共加密32轮    for (int i &#x3D; 0; i &lt; 32; i++)    &#123;        sum +&#x3D; delta;        x +&#x3D; ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);        y +&#x3D; ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);    &#125;    &#x2F;&#x2F;最后加密的结果重新写入到数组中    EntryData[0] &#x3D; x;    EntryData[1] &#x3D; y;&#125;void Decrypt(long* EntryData, long* Key)&#123;    &#x2F;&#x2F;分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组    unsigned long x &#x3D; EntryData[0];    unsigned long y &#x3D; EntryData[1];    unsigned long sum &#x3D; 0;    unsigned long delta &#x3D; 0x9E3779B9;    sum &#x3D; delta &lt;&lt; 5;   &#x2F;&#x2F;注意这里,sum &#x3D; 32轮之后的黄金分割值. 因为我们要反序解密.    &#x2F;&#x2F;总共加密32轮 那么反序也解密32轮    for (int i &#x3D; 0; i &lt; 32; i++)    &#123;        &#x2F;&#x2F; 先将y解开 然后参与运算在解x        y -&#x3D; ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);        x -&#x3D; ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);        sum -&#x3D; delta;    &#125;    &#x2F;&#x2F;最后加密的结果重新写入到数组中    EntryData[0] &#x3D; x;    EntryData[1] &#x3D; y;&#125;int main()&#123;    long Data[3] &#x3D; &#123; 0x44434241,0x48474645,0x0 &#125;;    printf(&quot;待加密的数值 &#x3D; %s\r\n&quot;, (char*)Data);    long key[4] &#x3D; &#123; 0x11223344,0x55667788,0x99AABBCC,0xDDEEFF11 &#125;;    &#x2F;&#x2F;Encrypt每次只是加密4字节数组中的两组(也就是每次加密8个字节) 如果你数据多.可以来个for循环来循环加密,但是Entrypt内部还有32次循环,所以速度上还是会有点影响.    Encrypt(Data, key);    printf(&quot;加密后的数值 &#x3D; %s\r\n&quot;, (char*)Data);    Decrypt(Data, key);    printf(&quot;解密后的数值 &#x3D; %s\r\n&quot;, (char*)Data);    system(&quot;pause&quot;);&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="XTEA机密算法"><a href="#XTEA机密算法" class="headerlink" title="XTEA机密算法"></a>XTEA机密算法</h4><ol><li>原理<br>与TEA加密算法类似，只是增加了更多的密钥表，移位和异或操作等等。  </li><li>代码实现  </li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;  #include &lt;stdint.h&gt;  void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;      unsigned int i;      uint32_t v0&#x3D;v[0], v1&#x3D;v[1], sum&#x3D;0, delta&#x3D;0x9E3779B9;      for (i&#x3D;0; i &lt; num_rounds; i++) &#123;          v0 +&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);          sum +&#x3D; delta;          v1 +&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);      &#125;      v[0]&#x3D;v0; v[1]&#x3D;v1;  &#125;  void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;      unsigned int i;      uint32_t v0&#x3D;v[0], v1&#x3D;v[1], delta&#x3D;0x9E3779B9, sum&#x3D;delta*num_rounds;      for (i&#x3D;0; i &lt; num_rounds; i++) &#123;          v1 -&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);          sum -&#x3D; delta;          v0 -&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);      &#125;      v[0]&#x3D;v0; v[1]&#x3D;v1;  &#125;  int main()  &#123;      uint32_t v[2]&#x3D;&#123;1,2&#125;;      uint32_t const k[4]&#x3D;&#123;2,2,3,4&#125;;      unsigned int r&#x3D;32;&#x2F;&#x2F;num_rounds建议取值为32      &#x2F;&#x2F; v为要加密的数据是两个32位无符号整数      &#x2F;&#x2F; k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位      printf(&quot;加密前原始数据：%u %u\n&quot;,v[0],v[1]);      encipher(r, v, k);      printf(&quot;加密后的数据：%u %u\n&quot;,v[0],v[1]);      decipher(r, v, k);      printf(&quot;解密后的数据：%u %u\n&quot;,v[0],v[1]);      return 0;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="XXTEA加密算法"><a href="#XXTEA加密算法" class="headerlink" title="XXTEA加密算法"></a>XXTEA加密算法</h4><ol><li>原理<br><img src="/2021/120547052/13.png" alt=" ">  </li><li>代码实现  </li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;  #include &lt;stdint.h&gt;  #define DELTA 0x9e3779b9  #define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))  void btea(uint32_t *v, int n, uint32_t const key[4])  &#123;      uint32_t y, z, sum;      unsigned p, rounds, e;      if (n &gt; 1)            &#x2F;* Coding Part *&#x2F;      &#123;          rounds &#x3D; 6 + 52&#x2F;n;          sum &#x3D; 0;          z &#x3D; v[n-1];          do          &#123;              sum +&#x3D; DELTA;              e &#x3D; (sum &gt;&gt; 2) &amp; 3;              for (p&#x3D;0; p&lt;n-1; p++)              &#123;                  y &#x3D; v[p+1];                  z &#x3D; v[p] +&#x3D; MX;              &#125;              y &#x3D; v[0];              z &#x3D; v[n-1] +&#x3D; MX;          &#125;          while (--rounds);      &#125;      else if (n &lt; -1)      &#x2F;* Decoding Part *&#x2F;      &#123;          n &#x3D; -n;          rounds &#x3D; 6 + 52&#x2F;n;          sum &#x3D; rounds*DELTA;          y &#x3D; v[0];          do          &#123;              e &#x3D; (sum &gt;&gt; 2) &amp; 3;              for (p&#x3D;n-1; p&gt;0; p--)              &#123;                  z &#x3D; v[p-1];                  y &#x3D; v[p] -&#x3D; MX;              &#125;              z &#x3D; v[n-1];              y &#x3D; v[0] -&#x3D; MX;              sum -&#x3D; DELTA;          &#125;          while (--rounds);      &#125;  &#125;  int main()  &#123;      uint32_t v[2]&#x3D; &#123;1,2&#125;;      uint32_t const k[4]&#x3D; &#123;2,2,3,4&#125;;      int n&#x3D; 2; &#x2F;&#x2F;n的绝对值表示v的长度，取正表示加密，取负表示解密      &#x2F;&#x2F; v为要加密的数据是两个32位无符号整数      &#x2F;&#x2F; k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位      printf(&quot;加密前原始数据：%u %u\n&quot;,v[0],v[1]);      btea(v, n, k);      printf(&quot;加密后的数据：%u %u\n&quot;,v[0],v[1]);      btea(v, -n, k);      printf(&quot;解密后的数据：%u %u\n&quot;,v[0],v[1]);      return 0;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DES加密算法"><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h4><ol><li>原理<br>利用一些简单的密码变换，如：代换、置换、加减等设计出一个圈函数f，并通过将他多次迭代的方法，产生的一个分组密码算法  </li><li>基本参数<br>分组长度：64bit<br>密钥长度：64bit<br>有效密钥长度：56bit(每8bit的最高位是校验码，检验错误)<br>迭代的圈数：16圈<br>圈密钥的长度：48bit  </li><li>加密完整的流程图<br><img src="/2021/120547052/36.png" alt=" ">  </li><li>解析  </li></ol><ul><li>初始置换IP和逆初始置换IP-1<br><img src="/2021/120547052/37.png" alt=" "><br>其中：初始置换中的数字序号代表的是最初给定的数字的序号，而逆初始置换中的数字是经过一系列操作之后现在得到的结果进行从开始进行从新排序之后的数字编号  </li><li>迭代16圈<br>前15圈的算法结构可以表示为：(Li,Ri)=(Ri-1,Li-1⊕f(Ri-1, Ki))<br>第16圈的算法结构可以表示为：(L16,R16)=(L15⊕f(R15,K16),R16)  </li><li>f函数解析  </li></ul><ol><li>f函数图解<br><img src="/2021/120547052/38.png" alt=" ">  </li><li>E盒扩展<br>目的：将输入的32bit数据扩展为48bit数据<br><img src="/2021/120547052/39.png" alt=" "><br>扩展方式解析：(1) 将输入的32比特每4比特为一组分为8块;<br>（2）分别将第m-1块的最右比特和第m+1块的最左比特添到第m块的左边和右边,形成输出的第k个6比特块  </li><li>S盒代换<br>目的：将输入的48bit数据压缩为32bit数据<br><img src="/2021/120547052/40.png" alt=" "><br>举例：<br><img src="/2021/120547052/41.png" alt=" ">  </li><li>P盒变换<br>目的：对S盒变换后的32比特数据的位置进行移动<br><img src="/2021/120547052/42.png" alt=" "><br>特点：（1）P盒的各输入块的4个比特都分配到不同的输出块之中<br>（2）P盒的各输出块的4个比特都来自不同的输入块<br>（3）P盒的第t输出块的4个比特都不来自第t输入块  </li></ol><ul><li>DES的圈密钥生成算法  </li></ul><ol><li>圈密钥生成算法图解<br><img src="/2021/120547052/43.png" alt=" ">  </li><li>置换选择1<br><img src="/2021/120547052/44.png" alt=" "><br>其中：将每8个bit的最高位的检验位去除，之后按照图表进行排序  </li><li>置换选择2<br><img src="/2021/120547052/45.png" alt=" "><br>其中：该序号时将进行操作之后的数据从新编号之后，按图表编号在取出数据  </li><li>移位情况<br><img src="/2021/120547052/46.png" alt=" ">  </li></ol><ul><li>解密情况<br>解密和加密的算法结构完全相同<br>密钥顺序相反  </li><li>加密解密算法  </li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*************************************************************************    &gt; File Name: Des.cpp    &gt; Author: SongLee    &gt; E-mail: lisong.shine@qq.com    &gt; Created Time: 2014年06月01日 星期日 19时46分32秒    &gt; Personal Blog: http:&#x2F;&#x2F;songlee24.github.com************************************************************************&#x2F;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;bitset&gt;#include &lt;string&gt;using namespace std;bitset&lt;64&gt; key;                &#x2F;&#x2F; 64位密钥bitset&lt;48&gt; subKey[16];         &#x2F;&#x2F; 存放16轮子密钥&#x2F;&#x2F; 初始置换表int IP[] &#x3D; &#123;58, 50, 42, 34, 26, 18, 10, 2,            60, 52, 44, 36, 28, 20, 12, 4,            62, 54, 46, 38, 30, 22, 14, 6,            64, 56, 48, 40, 32, 24, 16, 8,            57, 49, 41, 33, 25, 17, 9,  1,            59, 51, 43, 35, 27, 19, 11, 3,            61, 53, 45, 37, 29, 21, 13, 5,            63, 55, 47, 39, 31, 23, 15, 7&#125;;&#x2F;&#x2F; 结尾置换表int IP_1[] &#x3D; &#123;40, 8, 48, 16, 56, 24, 64, 32,            39, 7, 47, 15, 55, 23, 63, 31,            38, 6, 46, 14, 54, 22, 62, 30,            37, 5, 45, 13, 53, 21, 61, 29,            36, 4, 44, 12, 52, 20, 60, 28,            35, 3, 43, 11, 51, 19, 59, 27,            34, 2, 42, 10, 50, 18, 58, 26,            33, 1, 41,  9, 49, 17, 57, 25&#125;;&#x2F;*------------------下面是生成密钥所用表-----------------*&#x2F;&#x2F;&#x2F; 密钥置换表，将64位密钥变成56位int PC_1[] &#x3D; &#123;57, 49, 41, 33, 25, 17, 9,            1, 58, 50, 42, 34, 26, 18,            10,  2, 59, 51, 43, 35, 27,            19, 11,  3, 60, 52, 44, 36,            63, 55, 47, 39, 31, 23, 15,            7, 62, 54, 46, 38, 30, 22,            14,  6, 61, 53, 45, 37, 29,            21, 13,  5, 28, 20, 12,  4&#125;;&#x2F;&#x2F; 压缩置换，将56位密钥压缩成48位子密钥int PC_2[] &#x3D; &#123;14, 17, 11, 24,  1,  5,            3, 28, 15,  6, 21, 10,            23, 19, 12,  4, 26,  8,            16,  7, 27, 20, 13,  2,            41, 52, 31, 37, 47, 55,            30, 40, 51, 45, 33, 48,            44, 49, 39, 56, 34, 53,            46, 42, 50, 36, 29, 32&#125;;&#x2F;&#x2F; 每轮左移的位数int shiftBits[] &#x3D; &#123;1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1&#125;;&#x2F;*------------------下面是密码函数 f 所用表-----------------*&#x2F;&#x2F;&#x2F; 扩展置换表，将 32位 扩展至 48位int E[] &#x3D; &#123;32,  1,  2,  3,  4,  5,            4,  5,  6,  7,  8,  9,            8,  9, 10, 11, 12, 13,        12, 13, 14, 15, 16, 17,        16, 17, 18, 19, 20, 21,        20, 21, 22, 23, 24, 25,        24, 25, 26, 27, 28, 29,        28, 29, 30, 31, 32,  1&#125;;&#x2F;&#x2F; S盒，每个S盒是4x16的置换表，6位 -&gt; 4位int S_BOX[8][4][16] &#x3D; &#123;    &#123;        &#123;14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7&#125;,        &#123;0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8&#125;,        &#123;4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0&#125;,        &#123;15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13&#125;    &#125;,    &#123;        &#123;15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10&#125;,        &#123;3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5&#125;,        &#123;0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15&#125;,        &#123;13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9&#125;    &#125;,    &#123;        &#123;10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8&#125;,        &#123;13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1&#125;,        &#123;13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7&#125;,        &#123;1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12&#125;    &#125;,    &#123;        &#123;7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15&#125;,        &#123;13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9&#125;,        &#123;10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4&#125;,        &#123;3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14&#125;    &#125;,    &#123;        &#123;2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9&#125;,        &#123;14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6&#125;,        &#123;4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14&#125;,        &#123;11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3&#125;    &#125;,    &#123;        &#123;12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11&#125;,        &#123;10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8&#125;,        &#123;9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6&#125;,        &#123;4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13&#125;    &#125;,    &#123;        &#123;4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1&#125;,        &#123;13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6&#125;,        &#123;1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2&#125;,        &#123;6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12&#125;    &#125;,    &#123;        &#123;13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7&#125;,        &#123;1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2&#125;,        &#123;7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8&#125;,        &#123;2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11&#125;    &#125;&#125;;&#x2F;&#x2F; P置换，32位 -&gt; 32位int P[] &#x3D; &#123;16,  7, 20, 21,        29, 12, 28, 17,            1, 15, 23, 26,            5, 18, 31, 10,            2,  8, 24, 14,        32, 27,  3,  9,        19, 13, 30,  6,        22, 11,  4, 25 &#125;;&#x2F;**********************************************************************&#x2F;&#x2F;*                                                                    *&#x2F;&#x2F;*                            下面是DES算法实现                         *&#x2F;&#x2F;*                                                                    *&#x2F;&#x2F;**********************************************************************&#x2F;&#x2F;***  密码函数f，接收32位数据和48位子密钥，产生一个32位的输出*&#x2F;bitset&lt;32&gt; f(bitset&lt;32&gt; R, bitset&lt;48&gt; k)&#123;    bitset&lt;48&gt; expandR;    &#x2F;&#x2F; 第一步：扩展置换，32 -&gt; 48    for(int i&#x3D;0; i&lt;48; ++i)        expandR[47-i] &#x3D; R[32-E[i]];    &#x2F;&#x2F; 第二步：异或    expandR &#x3D; expandR ^ k;    &#x2F;&#x2F; 第三步：查找S_BOX置换表    bitset&lt;32&gt; output;    int x &#x3D; 0;    for(int i&#x3D;0; i&lt;48; i&#x3D;i+6)    &#123;        int row &#x3D; expandR[47-i]*2 + expandR[47-i-5];        int col &#x3D; expandR[47-i-1]*8 + expandR[47-i-2]*4 + expandR[47-i-3]*2 + expandR[47-i-4];        int num &#x3D; S_BOX[i&#x2F;6][row][col];        bitset&lt;4&gt; binary(num);        output[31-x] &#x3D; binary[3];        output[31-x-1] &#x3D; binary[2];        output[31-x-2] &#x3D; binary[1];        output[31-x-3] &#x3D; binary[0];        x +&#x3D; 4;    &#125;    &#x2F;&#x2F; 第四步：P-置换，32 -&gt; 32    bitset&lt;32&gt; tmp &#x3D; output;    for(int i&#x3D;0; i&lt;32; ++i)        output[31-i] &#x3D; tmp[32-P[i]];    return output;&#125;&#x2F;***  对56位密钥的前后部分进行左移*&#x2F;bitset&lt;28&gt; leftShift(bitset&lt;28&gt; k, int shift)&#123;    bitset&lt;28&gt; tmp &#x3D; k;    for(int i&#x3D;27; i&gt;&#x3D;0; --i)    &#123;        if(i-shift&lt;0)            k[i] &#x3D; tmp[i-shift+28];        else            k[i] &#x3D; tmp[i-shift];    &#125;    return k;&#125;&#x2F;***  生成16个48位的子密钥*&#x2F;void generateKeys()&#123;    bitset&lt;56&gt; realKey;    bitset&lt;28&gt; left;    bitset&lt;28&gt; right;    bitset&lt;48&gt; compressKey;    &#x2F;&#x2F; 去掉奇偶标记位，将64位密钥变成56位    for (int i&#x3D;0; i&lt;56; ++i)        realKey[55-i] &#x3D; key[64 - PC_1[i]];    &#x2F;&#x2F; 生成子密钥，保存在 subKeys[16] 中    for(int round&#x3D;0; round&lt;16; ++round)    &#123;        &#x2F;&#x2F; 前28位与后28位        for(int i&#x3D;28; i&lt;56; ++i)            left[i-28] &#x3D; realKey[i];        for(int i&#x3D;0; i&lt;28; ++i)            right[i] &#x3D; realKey[i];        &#x2F;&#x2F; 左移        left &#x3D; leftShift(left, shiftBits[round]);        right &#x3D; leftShift(right, shiftBits[round]);        &#x2F;&#x2F; 压缩置换，由56位得到48位子密钥        for(int i&#x3D;28; i&lt;56; ++i)            realKey[i] &#x3D; left[i-28];        for(int i&#x3D;0; i&lt;28; ++i)            realKey[i] &#x3D; right[i];        for(int i&#x3D;0; i&lt;48; ++i)            compressKey[47-i] &#x3D; realKey[56 - PC_2[i]];        subKey[round] &#x3D; compressKey;    &#125;&#125;&#x2F;***  工具函数：将char字符数组转为二进制*&#x2F;bitset&lt;64&gt; charToBitset(const char s[8])&#123;    bitset&lt;64&gt; bits;    for(int i&#x3D;0; i&lt;8; ++i)        for(int j&#x3D;0; j&lt;8; ++j)            bits[i*8+j] &#x3D; ((s[i]&gt;&gt;j) &amp; 1);    return bits;&#125;&#x2F;***  DES加密*&#x2F;bitset&lt;64&gt; encrypt(bitset&lt;64&gt;&amp; plain)&#123;    bitset&lt;64&gt; cipher;    bitset&lt;64&gt; currentBits;    bitset&lt;32&gt; left;    bitset&lt;32&gt; right;    bitset&lt;32&gt; newLeft;    &#x2F;&#x2F; 第一步：初始置换IP    for(int i&#x3D;0; i&lt;64; ++i)        currentBits[63-i] &#x3D; plain[64-IP[i]];    &#x2F;&#x2F; 第二步：获取 Li 和 Ri    for(int i&#x3D;32; i&lt;64; ++i)        left[i-32] &#x3D; currentBits[i];    for(int i&#x3D;0; i&lt;32; ++i)        right[i] &#x3D; currentBits[i];    &#x2F;&#x2F; 第三步：共16轮迭代    for(int round&#x3D;0; round&lt;16; ++round)    &#123;        newLeft &#x3D; right;        right &#x3D; left ^ f(right,subKey[round]);        left &#x3D; newLeft;    &#125;    &#x2F;&#x2F; 第四步：合并L16和R16，注意合并为 R16L16    for(int i&#x3D;0; i&lt;32; ++i)        cipher[i] &#x3D; left[i];    for(int i&#x3D;32; i&lt;64; ++i)        cipher[i] &#x3D; right[i-32];    &#x2F;&#x2F; 第五步：结尾置换IP-1    currentBits &#x3D; cipher;    for(int i&#x3D;0; i&lt;64; ++i)        cipher[63-i] &#x3D; currentBits[64-IP_1[i]];    &#x2F;&#x2F; 返回密文    return cipher;&#125;&#x2F;***  DES解密*&#x2F;bitset&lt;64&gt; decrypt(bitset&lt;64&gt;&amp; cipher)&#123;    bitset&lt;64&gt; plain;    bitset&lt;64&gt; currentBits;    bitset&lt;32&gt; left;    bitset&lt;32&gt; right;    bitset&lt;32&gt; newLeft;    &#x2F;&#x2F; 第一步：初始置换IP    for(int i&#x3D;0; i&lt;64; ++i)        currentBits[63-i] &#x3D; cipher[64-IP[i]];    &#x2F;&#x2F; 第二步：获取 Li 和 Ri    for(int i&#x3D;32; i&lt;64; ++i)        left[i-32] &#x3D; currentBits[i];    for(int i&#x3D;0; i&lt;32; ++i)        right[i] &#x3D; currentBits[i];    &#x2F;&#x2F; 第三步：共16轮迭代（子密钥逆序应用）    for(int round&#x3D;0; round&lt;16; ++round)    &#123;        newLeft &#x3D; right;        right &#x3D; left ^ f(right,subKey[15-round]);        left &#x3D; newLeft;    &#125;    &#x2F;&#x2F; 第四步：合并L16和R16，注意合并为 R16L16    for(int i&#x3D;0; i&lt;32; ++i)        plain[i] &#x3D; left[i];    for(int i&#x3D;32; i&lt;64; ++i)        plain[i] &#x3D; right[i-32];    &#x2F;&#x2F; 第五步：结尾置换IP-1    currentBits &#x3D; plain;    for(int i&#x3D;0; i&lt;64; ++i)        plain[63-i] &#x3D; currentBits[64-IP_1[i]];    &#x2F;&#x2F; 返回明文    return plain;&#125;&#x2F;**********************************************************************&#x2F;&#x2F;* 测试：                                                             *&#x2F;&#x2F;*     1.将一个 64 位的字符串加密， 把密文写入文件 a.txt                  *&#x2F;&#x2F;*     2.读取文件 a.txt 获得 64 位密文，解密之后再写入 b.txt              *&#x2F;&#x2F;**********************************************************************&#x2F;int main() &#123;    string s &#x3D; &quot;romantic&quot;;    string k &#x3D; &quot;12345678&quot;;    bitset&lt;64&gt; plain &#x3D; charToBitset(s.c_str());    key &#x3D; charToBitset(k.c_str());    &#x2F;&#x2F; 生成16个子密钥    generateKeys();    &#x2F;&#x2F; 密文写入 a.txt    bitset&lt;64&gt; cipher &#x3D; encrypt(plain);    fstream file1;    file1.open(&quot;D:&#x2F;&#x2F;a.txt&quot;, ios::binary | ios::out);    file1.write((char*)&amp;cipher,sizeof(cipher));    file1.close();    &#x2F;&#x2F; 读文件 a.txt    bitset&lt;64&gt; temp;    file1.open(&quot;D:&#x2F;&#x2F;a.txt&quot;, ios::binary | ios::in);    file1.read((char*)&amp;temp, sizeof(temp));    file1.close();    &#x2F;&#x2F; 解密，并写入文件 b.txt    bitset&lt;64&gt; temp_plain &#x3D; decrypt(temp);    file1.open(&quot;D:&#x2F;&#x2F;b.txt&quot;, ios::binary | ios::out);    file1.write((char*)&amp;temp_plain,sizeof(temp_plain));    file1.close();    return 0;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SM4加密算法"><a href="#SM4加密算法" class="headerlink" title="SM4加密算法"></a>SM4加密算法</h4><ol><li><p>加密解密流程图如下：<br><img src="/2021/120547052/52.png" alt=" ">  </p></li><li><p>加密  </p></li></ol><ul><li>输入的明文为 128bit 的数据将其按位拆分成 4 个 32bit 的数据x0,x1,x2,x3，当i=0 时为第一次轮变换，一直进行到 i=31 结束  </li><li>xi  暂时不做处理，将 xi+1,xi+2,xi+3 和轮密钥 rki 异或得到一个 32bit 的数据，作为盒变换的输入<br>即 sbox_input=xi+1⊕xi+2⊕xi+3⊕rki，⊕ 符号代表异或运算  </li><li>将 sbox_input 拆分成 4 个 8bit 数据，分别进行盒变换，之后再将 4 个 8bit 输出合并成一个 32bit 的 sbox_output  </li><li>将刚才获得的 sbox_output 分别循环左移 2，10，18，24 位，得到 4 个 32bit 的结果，记移位结果为 y2,y10,y18,y24  </li><li>将移位的结果 y2,y10,y18,y24 与盒变换输出 sbox_output 和 xi 异或，得到 xi+4<br>即 xi+4=sbox_output⊕y2⊕y10⊕y18⊕y24⊕xi  </li><li>至此完成了一轮的加解密运算<br>在实际加解密过程中，上述运算要执行 32 轮，同时使用 32 个不同的 rki，rki 由密钥拓展生成  </li><li>最后将生成的最后 4 个 32bit 数据 x35,x34,x33,x32 合并成一个 128bit 的数据 output，作为最后的输出结果<br>其中的盒变换的盒子如下图<br><img src="/2021/120547052/49.png" alt=" ">  </li></ul><ol><li>密钥拓展  </li></ol><ul><li>输入的原始密钥 key 为 128bit 的数据，将其按位拆分成 4 个 32bit 的数据 K0,K1,K2,K3  </li><li>将初始密钥 K0,K1,K2,K3 分别异或固定参数 FK0,FK1,FK2,FK3 得到用于循环的密钥 k0,k1,k2,k3<br>即 k0=K0⊕FK0,k1=K1⊕FK1,k2=K2⊕FK2,k3=K3⊕FK3  </li><li>进入轮密钥 rki 的生成<br>当 i=0 时为第一次轮变换，一直进行到 i=31 结束  </li><li>ki  暂时不做处理，将 ki+1,ki+2,ki+3 和固定参数 CKi 异或得到一个 32bit 的数据，作为盒变换的输入<br>即 sbox_input=ki+1⊕ki+2⊕ki+3⊕cki  </li><li>将 sbox_input 拆分成 4 个 8bit 数据，分别进行盒变换，之后再将 4 个 8bit 输出合并成一个 32bit 的 sbox_output  </li><li>将刚才获得的 sbox_output 分别循环左移 13，23 位，得到 2 个 32bit 的结果，记移位结果为 y13,y23  </li><li>将移位的结果 y13,y23 与盒变换输出 sbox_output 和 ki 异或，得到 ki+4<br>即 rki=ki+4=sbox_output⊕y13⊕y23⊕ki  </li><li>至此完成了一轮的加解密运算<br>在实际加解密过程中，上述运算要执行 32 轮，同时使用 32 个不同的 CKi，CKi 为固定参数  </li><li>执行完 32 轮后，便可获得 32 个用于加解密的 rki<br>其中要用的盒子上面有，CK和FK如下图<br>FK：<br><img src="/2021/120547052/50.png" alt=" "><br>CK:<br><img src="/2021/120547052/51.png" alt=" ">  </li></ul><h3 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>分组密码的工作模式是指以这个分组密码为基础通过某种方式构造一个分组密码系统，以解决对任意长度明文的加密问题  </li></ol><h4 id="1电码本-ECB-模式"><a href="#1电码本-ECB-模式" class="headerlink" title="1电码本(ECB)模式"></a>1电码本(ECB)模式</h4><ol><li>ECB 模式是直接使用分组密码的工作模式，明文的各个分组独立地使用同一密钥 k 加密  </li><li>加解密框图如下：<br><img src="/2021/120547052/53.png" alt=" ">  </li><li>分组短块<br>直接扩充法–直接补0或者其他固定bit–添加随机数(填充的最好是可以识别身份的)<br>密文挪用法–从最后的密文开始在最后进行填充  </li></ol><h4 id="密码分组链接-CBC-模式"><a href="#密码分组链接-CBC-模式" class="headerlink" title="密码分组链接(CBC)模式"></a>密码分组链接(CBC)模式</h4><ol><li>加密<br><img src="/2021/120547052/54.png" alt=" ">  </li><li>解密<br><img src="/2021/120547052/55.png" alt=" ">  </li></ol><h4 id="密码反馈-CFB-模式"><a href="#密码反馈-CFB-模式" class="headerlink" title="密码反馈(CFB)模式"></a>密码反馈(CFB)模式</h4><ol><li>加密<br><img src="/2021/120547052/56.png" alt=" ">  </li><li>解密<br><img src="/2021/120547052/57.png" alt=" ">  </li></ol><h4 id="输出反馈-OFB-模式"><a href="#输出反馈-OFB-模式" class="headerlink" title="输出反馈(OFB)模式"></a>输出反馈(OFB)模式</h4><ol><li>加密<br><img src="/2021/120547052/58.png" alt=" ">  </li><li>解密<br><img src="/2021/120547052/59.png" alt=" ">  </li></ol><h4 id="计数器-CTR-模式"><a href="#计数器-CTR-模式" class="headerlink" title="计数器(CTR)模式"></a>计数器(CTR)模式</h4><ol><li>原理：利用固定密钥k对自然数序列1,2,3,…,n, …加密，将得到的密文分组序列看作乱数序列。按加减密码的方式与明文分组逐位模2加的一种方式  </li></ol><h2 id="其他密码学"><a href="#其他密码学" class="headerlink" title="其他密码学"></a>其他密码学</h2><h3 id="base加密"><a href="#base加密" class="headerlink" title="base加密"></a>base加密</h3><ol><li><p>原理<br>a. 将三个八位的字节转化为四个六位的字节，不足补零。它是用64个可打印字符表示二进制所有数据方法。由于2的6次方等于64，所以可以用每6个位元为一个单元，对应某个可打印字符。我们知道三个字节有24个位元，就可以刚好对应于4个Base64单元，即3个字节需要用4个Base64的可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9 ，这样共有62个字符，此外两个可打印符号在不同的系统中一般有所不同。但是，我们经常所说的Base64另外2个字符是：“+/”。这64个字符，所对应的索引表如下(索引号不是对应的ascii值)：<br><img src="/2021/120547052/11.png" alt=" "><br>b. 转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。所以加密后的数据量是原来的4/3。<br>c. 但转换的字节数不一定就是24的整数倍，会出现有多余不足六位的情况，在base64中处理的方法是加零凑够六位，但是这样一来在解码的时候就会出现多余的位，这该怎么办呢？ 不用担心，base64想到了一个很好的解决办法。<br>​d. 这个办法就是在base64凑零的同时，还要满足凑出来的位数是8的倍数，不然就加一个或者两个特殊的六位=符号。为什么是一个或者两个=符号呢？因为多个8位转为6位 只会出现剩余2位、4位的情况，剩余2位时只需要一个表示六位的=便可变为8的整数；而剩余4位 需要两个表示6位的=便可以变为8的整数。然后在解密的时候不解析=即可。<br>​之所以位的总数需要凑成8的倍数，是因为base64主要用于加密后的数据传送，而在传送机制中都认为传送的最小单位是按照字节算的，所以不能出现不是位总数不是8的倍数的情况，在接收到数据后，按顺序将6位的base64直接按照顺序解密成字节就完成解密了。<br><img src="/2021/120547052/12.png" alt=" ">  </p></li><li><p>base加密系列字母表  </p></li><li><p><strong>base16：0到9，A到F<a href="https://www.qqxiuzi.cn/bianma/base.php?type=16">在线解密</a></strong>  </p></li><li><p><strong>base32：A到Z，2到7<a href="https://www.qqxiuzi.cn/bianma/base.php">在线解密</a></strong>  </p></li><li><p>base36：0到9，a到z<a href="http://ctf.ssleye.com/base36w.html">在线解密</a>  </p></li><li><p><strong>base58:1到9，a到z，A到Z<a href="http://www.metools.info/code/c74.html">在线解密</a></strong>  </p></li><li><p><strong>base62:0到9，a到z，A到Z<a href="http://www.atoolbox.net/Tool.php?Id=933">在线解密</a></strong>  </p></li><li><p><strong>base64:a到z，A到Z，0到9，特别地有/+（可以转图片）<a href="https://tool.oschina.net/encrypt?type=3">在线解密</a></strong>  </p></li><li><p><strong>base91：A到Z，a到z，0到9，!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`{|}~）<a href="http://www.atoolbox.net/Tool.php?Id=935">在线解密</a></strong>  </p></li><li><p><strong>base92：0到9，A到Z，a到z，!#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_{|｝<a href="http://ctf.ssleye.com/base92.html">在线解密</a></strong>  </p></li><li><p><strong>base128：0到9，A到Z，a到z，\xb5\xb6\xb7\xbc\xbd\xbe\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff</strong>  </p></li></ol><h3 id="Hash-哈希算法"><a href="#Hash-哈希算法" class="headerlink" title="Hash(哈希算法)"></a>Hash(哈希算法)</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>特征：md5加密后是16位或者32位的字符，由字母和数字组成，字母大小写统一；<br>理论上无法解密，除非暴力破解  </p><h4 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h4><p>特征：SHA-1加密后的密文是40个字符，并且由数字字母组成；  </p><h4 id="SHA-2"><a href="#SHA-2" class="headerlink" title="SHA-2"></a>SHA-2</h4><p>特征：SHA-2 又分为两种算法，SHA-224 和 SHA-256。两者生成的密文都是由 0-9a-fA-F 组成的，其中 SHA-224 的密文长度固定是 56，SHA-256 的密文长度是 64 。  </p><h3 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>原理:  </p><ul><li>利用密钥K产生一个密钥流z=z0z1z2…，并使用如下规则对明文串x=x0x1x2…加密：y=y0y1y2=Ez0(x0)Ez1(x1)Ez2(x2)…  </li><li>密钥流由密钥流发生器产生：Z=f(k,σi),这里σi是加密器中的记忆元件（储存器）在时刻i的状态，f是由密钥k和σi产生的函数。  </li></ul><p>其他：  </p><ul><li>分组密码与流密码的区别就在于有无记忆性  </li><li>同步流密码概念模型如下<br><img src="/2021/120547052/13.png" alt=" ">  </li><li>有限状态自动机逻辑类似逻辑设计学习中的现态次态状态表  </li><li>密钥流产生器  </li></ul><ol><li>一般组成为：一个参数为K的有限状态自动机，由一个输出符号集z、一个状态集Σ、两个函数φ和ψ以及一个初始状态σ0  </li><li>方式：状态转移函数φ：σi-&gt;σi+1，将当前状态σi变为一个新状态σi+1，输出函数ψ:σi-&gt;Zi，当前状态σi变为输出符号集中的一个元素Zi  </li><li>采用方法：非线性函数的方法  </li><li>作为有限状态自动机的密钥流生成器和密钥流生成器分解图如下：<br><img src="/2021/120547052/14.png" alt=" ">  </li><li>常见的两种密钥流产生器如下图<br><img src="/2021/120547052/15.png" alt=" ">  </li></ol><h4 id="线性反馈移位寄存器"><a href="#线性反馈移位寄存器" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h4><ul><li>概念：移位寄存器是六密码产生密钥流的一个主要组成部分  </li><li>GF(2)上的n级反馈移位寄存器如下图<br><img src="/2021/120547052/16.png" alt=" ">  </li><li>我们常用的一般是这种：<br><img src="/2021/120547052/17.png" alt=" ">  </li><li>公式是：<br><img src="/2021/120547052/18.png" alt=" ">  </li><li>说明：其中的C1…Cn反应的应该是a0…an是否参与反馈，这种一般都会有一个周期  </li></ul><h4 id="线性反馈移位寄存器的一元多项式表示"><a href="#线性反馈移位寄存器的一元多项式表示" class="headerlink" title="线性反馈移位寄存器的一元多项式表示"></a>线性反馈移位寄存器的一元多项式表示</h4><ul><li>形式<br>设n级线性移位寄存器的输出序列{ai}满足递推关系：<br><img src="/2021/120547052/19.png" alt=" "><br>对任何K&gt;=1成立，这种递推关系可用一个一元高次多项式<br><img src="/2021/120547052/20.png" alt=" "><br>表示，称这个多项式为LFSR的特征多项式  </li><li>相关定理  </li></ul><p>2.1定义及定理<br><img src="/2021/120547052/21.png" alt=" "><br>2.2定理及定义<br><img src="/2021/120547052/22.png" alt=" "><br><img src="/2021/120547052/23.png" alt=" "><br><img src="/2021/120547052/24.png" alt=" "><br>2.3定义及定理<br><img src="/2021/120547052/25.png" alt=" "><br><img src="/2021/120547052/26.png" alt=" "><br>2.4定理<br><img src="/2021/120547052/27.png" alt=" "><br>2.5定理<br><img src="/2021/120547052/28.png" alt=" "><br>2.4定义和2.6定理<br><img src="/2021/120547052/29.png" alt=" "><br><img src="/2021/120547052/30.png" alt=" ">  </p><h4 id="m序列的伪随机性"><a href="#m序列的伪随机性" class="headerlink" title="m序列的伪随机性"></a>m序列的伪随机性</h4><ul><li>流密码的安全性取决于密钥流的安全性  </li><li>游程的概念：00110：0的2游程、1的2游程、0的1游程  </li><li>定义2.5<br><img src="/2021/120547052/31.png" alt=" ">  </li><li>Golomb对伪随机周期序列提出了应满足的如下三个随机性公设：  </li></ul><p>1.在序列的一个周期内，0与1的个数相差至多为1<br>2.在序列的一个周期内，长为1的游程占游程总数的1/2，长为2的游程占游程总数的(1/2)^2,…,长为i的游程占游程总数的(1/2)^i,且在等长的游程中0的游程个数和1的游程个数相等<br>3.异自相关函数是一个常数  </p><ul><li>从密码系统的角度看，一个伪随机序列还应满足下面的条件:  </li></ul><p>1.{ai}的周期相当大<br>2.{ai}的确定在计算上是容易的<br>3.{ai}由密文及相应的明文的部分信息,不能确定整个{ai}  </p><ul><li>定理2.7<br><img src="/2021/120547052/32.png" alt=" ">  </li></ul><h4 id="m序列的破译"><a href="#m序列的破译" class="headerlink" title="m序列的破译"></a>m序列的破译</h4><p>例如：<br>设敌手得到密文串101101011110010和相应的明文串  011001111111001，因此可计算出相应的密钥流为110100100001011。进一步假定敌手还知道密钥流是使用5级线性反馈移位寄存器产生的，那么敌手可分别用密文串中的前10个比特和明文串中的前10个比特建立如下方程<br><img src="/2021/120547052/33.png" alt=" "><br>之后：<br><img src="/2021/120547052/34.png" alt=" "><br>最后得到：<br><img src="/2021/120547052/35.png" alt=" ">  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向题</title>
      <link href="/2021/120454815.html"/>
      <url>/2021/120454815.html</url>
      
        <content type="html"><![CDATA[<h2 id="逆向题"><a href="#逆向题" class="headerlink" title="逆向题"></a>逆向题</h2><h3 id="招新时期的题-haha-exe"><a href="#招新时期的题-haha-exe" class="headerlink" title="招新时期的题:haha.exe"></a>招新时期的题:haha.exe</h3><ol><li>首先，这道题放入Exeinfo PE中查看这道题的简单情况如下:  </li></ol><p><img src="/2021/120454815/1.png" alt=" "></p><p>在这几个界面，首先 1 的位置显示的是文件的名称；2 的位置显示的是文件信息，如果加壳会显示是什么壳；3 的位置显示的文件是32位还是64位，便于分析；4 的位置显示的是编写这个文件使用的哪种语言；5 中最开始显示是否带壳；之后提示打开文件可以运用的文件<br>2. 其次，haha.exe这个文件是一个可运行的程序，但是当你打开输入信息的时候会自动闪退，放入32位ida的时候可以看到该main()函数的地址一致会变化，这也是程序打开闪退的原因，针对这个问题，可以使用 studyPE 这个软件来固定基址，从而解决闪退的问题。<br>3. 再一，文件打开之后，F5显示伪代码(语法神似c语言)，这时候根据之前文件的正常运行，会将含有flag信息的代码信息直接跳过，例如:<br><img src="/2021/120454815/2.png" alt=" ">类似上图一样，涵盖flag的信息全没有<br>4. 再二，返回初始界面，根据流程图进行分析<br><img src="/2021/120454815/3.png" alt=" "><br>分析可以知道在004012F4位置原来有一个跳转，上面那个语法会满足跳转条件，从而让我们想要的信息被跳过，所以这时候我们需要将它nop掉来阻止跳转，结果如图<br>5. 再三，在进行上述操作之后，可以再次找到main(),F5显示伪代码，这个时候就可以分析了，看下图<br><img src="/2021/120454815/4.png" alt=" "><br>在这个图里分析可以看到，输入 1 会得到一个flag.doc文件，2走迷宫，3退出，同时分析知flag.doc打开之后要密码，即我们要走迷宫，然后分析到sub_401120()这里，点开如下<br><img src="/2021/120454815/6.png" alt=" "><br>在这里可以看到用wasd走迷宫，同时分析知迷宫格式在V5=dword_403300[v4 + v2]这里，之后走迷宫即可，之后得到的字符串需要在LABEL_15地址进行异或操作，得到真正的密码字符串<br>6. 最后，如下图<br><img src="/2021/120454815/7.png" alt=" "><br>最后flag改为henu，同时注意最好以命令行的形式打开.exe文件，不然还是会出现闪退的问题(这个应该不是基址的问题了)<br>7. 总结：<br>关键点:固定基址，除掉跳转(nop),程序打开方式  </p><h3 id="BUUCTF-reverse3-含base64加密"><a href="#BUUCTF-reverse3-含base64加密" class="headerlink" title="BUUCTF-reverse3(含base64加密)"></a>BUUCTF-reverse3(含base64加密)</h3><ol><li>用exeinfope.exe程序查看题的情况<br><img src="/2021/120454815/8.png" alt=" ">  </li><li>用32为ida打开文件，之后再边框下拉到最下面找到main函数入口，之后F5打开反汇编窗口。<br><img src="/2021/120454815/9.png" alt=" "><br><img src="/2021/120454815/10.png" alt=" ">  </li><li>之后可以看到如上诉照片的情况，依次分析  <ul><li>加密<br><img src="/2021/120454815/11.png" alt=" "><br><img src="/2021/120454815/12.png" alt=" "><br>可以看到此加密方式是base64加密方式  </li><li>算法处理  </li><li>比较操作之后的flag与str2的大小，所以我们可以先找到str2的字符串之后进行一系列上述操作解出flag<br><img src="/2021/120454815/13.png" alt=" "><br>str2字符串  </li></ul></li><li>脚本  </li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">import base64s &#x3D; &quot;e3nifIH9b_C@n@dH&quot;x &#x3D; &quot;&quot;for i in range(0,len(s)):    x +&#x3D; chr(ord(s[i]) - i)print(base64.b64decode(x))  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="buuctf-SimpleRev-字符串的组合，输入判断"><a href="#buuctf-SimpleRev-字符串的组合，输入判断" class="headerlink" title="buuctf SimpleRev(字符串的组合，输入判断)"></a>buuctf SimpleRev(字符串的组合，输入判断)</h3><ol><li>用exeinfope.exe程序查看题的情况<br><img src="/2021/120454815/14.png" alt=" ">  </li><li>之后用64位IDA打开文件，找到对应的main函数之后F5打开反汇编窗口<br><img src="/2021/120454815/15.png" alt=" "><br>可以看到一个关键(Decry()),之后双击点开<br><img src="/2021/120454815/16.png" alt=" "><br><img src="/2021/120454815/17.png" alt=" ">  </li><li>1处：我们首先将*src,v9的16进制数据转换成字符串形式<br>2处：进行了三次组合:text = key3+v9,key = key +key1,key=key+src,三个依次进行，同时key1和key3可以直接双击点开查看<br>3处：进行变换，将key字符串中的大写字母变换成小写字母<br>4处：输入v1，同时知道输入字符之间有空格<br>5处：算法进行求str2<br>6处：test与str2进行比较，相同即满足条件  </li><li>脚本  </li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">src &#x3D; &#39;NDCLS&#39;v9 &#x3D; &#39;hadow&#39;key1 &#x3D; &#39;ADSFK&#39;key3 &#x3D; &#39;kills&#39;text1 &#x3D; key3 + v9       # 这里的text1相当于 text &#x3D; key3 + v9text2 &#x3D; key1 + src      # 这里的text2相当于 key &#x3D; key1 + srctext2 &#x3D; text2.lower()   # 需要把大学字母变为小写字母flag &#x3D; &quot;&quot;for i in range(0,len(text1)):    for x in range(0,128):      # 这里用暴力求解        if chr(x).isalpha():    # 这里要加上判断x是否是字符串            temp &#x3D; (x - 39 - ord(text2[i]) + 97) % 26 + 97            if text1[i] &#x3D;&#x3D; chr(temp):                   flag &#x3D; flag + chr(x)                breakprint(&quot;flag&#123;&quot;+flag+&quot;&#125;&quot;)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BUUCTF-ACTF新生赛2020-easyre"><a href="#BUUCTF-ACTF新生赛2020-easyre" class="headerlink" title="BUUCTF [ACTF新生赛2020]easyre"></a>BUUCTF [ACTF新生赛2020]easyre</h3><ol><li>先查看文件信息，发现含有upx壳，之后用解壳工具upx或者od手动脱壳，之后拖入32位ida，找到main函数–&gt;F5<br><img src="/2021/120454815/18.png" alt=" "></li><li>1处：将字符串*F’&quot;N,&quot;(I?+@复制给V4<br>2处：R字符串转换可以看出与flag有关，且结合第三处可以知道，flag有12位<br>3处：进行查询变换，点开3处的_data_start__(),可以看到以下情况<br><img src="/2021/120454815/19.png" alt=" "><br>再结合三处情况可以知道，<em>data_start</em>_()里的字符串[i]-1，如果与v4[i]相等，则该字符串[i]即为flag里的一个字符串  </li><li>脚本  </li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">flag1 &#x3D; &quot;*F&#39;\&quot;N,\&quot;(I?+@&quot;s &#x3D; list(flag1)flag&#x3D;&quot;&quot;string &#x3D; chr(0x7E)+&quot;&#125;|&#123;zyxwvutsrqponmlkjihgfedcba&#96;_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;&#x3D;&lt;;:9876543210&#x2F;.-,+*)(&quot; + chr(0x27) + &#39;&amp;%$# !&quot;&#39;for i in flag1:    for j in range(1,len(string)):        if ord(i) &#x3D;&#x3D; ord(string[j]):            flag+&#x3D;chr(j+1)print (&quot;flag&#123;&quot;+flag+&quot;&#125;&quot;)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BUUCTF-2019红帽杯-easyRE"><a href="#BUUCTF-2019红帽杯-easyRE" class="headerlink" title="BUUCTF [2019红帽杯]easyRE"></a>BUUCTF [2019红帽杯]easyRE</h3><ol><li>查看文件情况，无壳，64位，之后ida打开，发现没有main函数，之后shirt+F12，看到字符串You found me!!!双击，之后根据旁边找到它的地址在他地址进行反汇编<br><img src="/2021/120454815/20.png" alt=" "><br><img src="/2021/120454815/21.png" alt=" ">  </li><li>1、2、3处：将字符串分别复制给v12、v13、v14、同时v12[12] = 127 v13[3] = 127<br>4处：我们可以知道所求的字符串的长度是36<br>5处：进行了一个36位长度的异或操作，同时猜想可以知道此时的v12就是上述v12、v13、v14<br>之后疑惑可以指的，含有flag字符串，但不是我们想要的<br><img src="/2021/120454815/22.png" alt=" ">  </li><li>之后我们向下分析，可以看到这个图片里的东西，之后点开可以发现一串字符串，且编码形式是base64，我们将其解密到最后会发现最后给的是一个地址，不是flag<br><img src="/2021/120454815/23.png" alt=" ">  </li><li>继续向下分析，可以看到这里调用了off_6CC090，点开可以看到下面情况<br><img src="/2021/120454815/24.png" alt=" ">  </li><li>6处：我们之后会用到<br>7处：我们点击，之后跳到对应位置F5<br><img src="/2021/120454815/25.png" alt=" ">  </li><li>这才是flag的藏身之地，由上面那个箭头，我们可以猜出v1==v4==flag<br>之后我们用下面那个箭头所指结合6处和v4求出flag  </li><li>脚本  </li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">v5 &#x3D; &#39;&#39;enc1 &#x3D; &#39;flag&#39;v2 &#x3D; &#39;&#39;enc &#x3D; [0x40,0x35,0x20,0x56,0x5D,0x18,0x22,0x45,0x17,0x2F,0x24,0x6E,0x62,0x3C,0x27,0x54,0x48,0x6C,0x24,0x6E,0x72,0x3C,0x32,0x45,0x5B]for i in range(4):    v5 +&#x3D; chr(enc[i] ^ ord(enc1[i]))print (v5)for i in range(len(enc)):    v2 +&#x3D; chr(enc[i] ^ ord(v5[i%4]))print(v2)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BUUCTF-MRCTF2020-Xor-扩展思维"><a href="#BUUCTF-MRCTF2020-Xor-扩展思维" class="headerlink" title="BUUCTF [MRCTF2020]Xor(扩展思维)"></a>BUUCTF [MRCTF2020]Xor(扩展思维)</h3><ol><li>查看文件情况，无壳，32位，之后ida打开，发现main函数，在main函数位置进行反汇编，发现如下情况<br><img src="/2021/120454815/26.png" alt=" ">  </li><li>之后到对应位置<br><img src="/2021/120454815/27.png" alt=" "><br>分析发现是无法正确识别调用问题的原因(call analysis failed问题总结于逆向中的一些基础中)  </li><li>之后在该位置进行双击进入该函数，并反汇编，然后在对main函数进行反汇编就行了<br><img src="/2021/120454815/28.png" alt=" ">  </li><li>该题脚本  </li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">flag &#x3D;chr(77)+&#39;SAWB~FXZ:J:&#96;tQJ&quot;N@ bpdd&#125;8g&#39;s &#x3D; list(flag)for i in range(len(flag)):    s[i] &#x3D; chr(ord(s[i])^i)flag &#x3D; &quot;&quot;.join(s)print(flag)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BUUCTF-WUSTCTF2020-level1-文件读写"><a href="#BUUCTF-WUSTCTF2020-level1-文件读写" class="headerlink" title="BUUCTF [WUSTCTF2020]level1(文件读写)"></a>BUUCTF [WUSTCTF2020]level1(文件读写)</h3><ol><li>查看文件情况，无壳，64位，之后ida打开，发现main函数，在main函数位置进行反汇编<br><img src="/2021/120454815/29.png" alt=" ">  </li><li>1处：对文件flag进行读操作，可以猜想其实就是将flag读过来<br>2处：将读入的flag赋值给ptr<br>3处：关闭原文件<br>4处：对得到的flag进行一个简单的算法操作  </li><li>首先如果我们如果双击flag，我们会很“巧合”的发现下方正好有一个好像符合长度的一串16禁止数据，如下图<br><img src="/2021/120454815/30.png" alt=" "><br>之后我们对其进行编写脚本，发现这并不是我们想要的flag  </li><li>之后我们考虑、刚开始我们解压缩的时候还得到了一个.txt文件，总所周知，大部分情况有读就要有写吧，然后我们去打开那个.txt文件，发现一串数据，正好19个<br><img src="/2021/120454815/31.png" alt=" "><br>之后我们对这一串数据进行脚本，发现最后正好得到flag，大功告成  </li><li>脚本  </li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">ptr &#x3D; [198,232,816,200,1536,300,6144,984,51200,570,92160,1200,565248,756,1474560,800,6291456,1782,65536000]for i in range(19):    if (i+1) &amp; 1 !&#x3D; 0:        print(chr(ptr[i] &gt;&gt; (i+1)),end&#x3D;&quot;&quot;)    else:        print (chr(ptr[i] &#x2F;&#x2F; (i+1)),end&#x3D;&quot;&quot;)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BUUCTF-GWCTF-2019-xxor-类似tea加密"><a href="#BUUCTF-GWCTF-2019-xxor-类似tea加密" class="headerlink" title="BUUCTF [GWCTF 2019]xxor(类似tea加密)"></a>BUUCTF [GWCTF 2019]xxor(类似tea加密)</h3><ol><li>查看文件情况，无壳，64位，之后ida打开，发现main函数，在main函数位置进行反汇编<br><img src="/2021/120454815/32.png" alt=" ">  </li><li>1处：我们可以看出其实我们输入的应该是v6，最后进行求a2，我们猜想下a2可能是我们要的flag，但是下面第三部却对a2进行了赋值，这就导致猜错了，不过不慌，继续向下看<br>2处：进行循环 3次循环（关键点别忘了）<br>3处：对a2进行赋值，如下图<br><img src="/2021/120454815/33.png" alt=" "><br>4处：是对a1的6个数值进行的类似tea加密的操作，但不是严格tea加密形式，并且每次操作a1的两位数据<br><img src="/2021/120454815/34.png" alt=" "><br>5处：是对a1的6位数值的计算位置，在这个位置可以得出a1的6个值<br>6处：对于得到的16进制数值要转化为字符串(自己写的python代码没转化成，就去网上扣了一个c++的脚本)  </li><li>整体看完之后，我们可以直观的分析到我们其实要的就是最初的a1的那6个数值，所以在这里我们首先要求出a1的最终数值，之后从下到上反向的操作，求最初的数据<br>在5处，我们可以先求出a1的最终数据，因为这里只是简单的赋值，减法操作，其实我们可以很简单就写出来，就不附加上脚本了，之后我们在4处进行逆运算求最初的a1的6个数值即可  </li><li>脚本  </li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#pragma warning(disable:4996)using namespace std;int main()&#123;    __int64 a[6] &#x3D; &#123; 3746099070, 550153460, 3774025685, 1548802262, 2652626477, 2230518816 &#125;;    unsigned int a2[4] &#x3D; &#123; 2,2,3,4 &#125;;    unsigned int v3, v4;    int v5;    for (int j &#x3D; 0; j &lt;&#x3D; 4; j +&#x3D; 2) &#123;        v3 &#x3D; a[j];        v4 &#x3D; a[j + 1];        v5 &#x3D; 1166789954*0x40;        for (int i &#x3D; 0; i &lt;&#x3D; 0x3F; ++i) &#123;            v4 -&#x3D; (v3 + v5 + 20) ^ ((v3 &lt;&lt; 6) + a2[2]) ^ ((v3 &gt;&gt; 9) + a2[3]) ^ 0x10;            v3 -&#x3D; (v4 + v5 + 11) ^ ((v4 &lt;&lt; 6) + *a2) ^ ((v4 &gt;&gt; 9) + a2[1]) ^ 0x20;            v5 -&#x3D; 1166789954;        &#125;        a[j] &#x3D; v3;        a[j + 1] &#x3D; v4;    &#125;    &#x2F;*将整型数组作为字符输出，注意计算机小端排序*&#x2F;    for (int i &#x3D; 0; i &lt; 6; ++i) &#123;        cout &lt;&lt; *((char*)&amp;a[i] + 2) &lt;&lt; *((char*)&amp;a[i] + 1) &lt;&lt;  * ((char*)&amp;a[i]);    &#125;    system(&quot;PAUSE&quot;);    return 0;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BUUCTF-CrackRTF-拓宽思路"><a href="#BUUCTF-CrackRTF-拓宽思路" class="headerlink" title="BUUCTF CrackRTF(拓宽思路)"></a>BUUCTF CrackRTF(拓宽思路)</h3><ol><li>查看文件情况，无壳，32位，之后ida打开，发现main函数，在main函数位置进行反汇编<br><img src="/2021/120454815/36.png" alt=" "><br><img src="/2021/120454815/37.png" alt=" ">  </li><li>1处：先是对Destination、String1进行初始化，之后对Destination进行赋值，然后进行判断其长度是否等于6，等于6就符合要求<br>2处：显示将字符串Destination转换成（int）整形并赋值给v7，之后判断，如果v7&lt;100000，就不符合条件，所以我们知道v7&gt;100000<br>3处：将@DBApp子符串附加给Destination<br>4处：进行一个操作，具体情况如下图<br><img src="/2021/120454815/38.png" alt=" "><br>在这里我们可以看出该加密算法是哈希算法加密，并且由标识符0x8004u这里分析处使用的是SHA-1加密形式<br><a href="https://my.oschina.net/kivensoft/blog/549369">了解该形式加密解密算法请点击此处</a><br><a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id">标识符的官方文档请点击此处</a><br>5处：可以知道String1 == 6E32D0943418C2C33385BC35A1470250DD8923A9  </li><li>由五处我们就可以先接触flag的前六个字符串了  </li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">import hashlibstring&#x3D;&#39;@DBApp&#39;for i in range(100000,999999):    flag&#x3D;str(i)+string    x &#x3D; hashlib.sha1(flag.encode(&quot;utf8&quot;))    y &#x3D; x.hexdigest()    if &quot;6e32d0943418c2c33385bc35a1470250dd8923a9&quot; &#x3D;&#x3D; y:            print(flag)            break  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为长度有限直接暴力破解(看到别人的不会暴力破解，学习，学习)<br>04. 6处：我们同样要输入长度是6的串<br>7处：同样进行4处的操作<br>8处：可以知道这次String1 == 27019e688a4e62a649fd99cadaafdb4e<br>但是无法爆破了，不知到怎么办，不会，向下看<br>05. 9处也是一个函数，双击进去看看<br><img src="/2021/120454815/39.png" alt=" "><br>06. 对于上面这张图我们从上往下看<br>首先是一个FindResourceA()函数，这个我们查过之后可以知道是找句柄的，并且是从AAA资源中找句柄的<br>再者这个是如果知道到了所要的资源就将其大小(长度)记录下来<br>然后这个是如果知道到了所要的资源就将其值赋给lpBuffer<br>最后一个函数操作并生成一个.rtf文件，函数操作如下<br><img src="/2021/120454815/40.png" alt=" "><br>同时分析知在该函数中其实就是资源的每一位和密码的每一位循环异或<br>异或结束之后，生成一个rtf文件<br>同时知道<br>我们的密码一共是6+12=18位<br>我们现在想要的是前六位的密码，循环异或的话，那么也就是说，资源的前六位与密码的前六位异或的结果就是rtf文件的前六位<br>07. 我们找来一个rtf文件，看看它的标志位<br><img src="/2021/120454815/41.png" alt=" "><br>前六位是{\rtfl<br>08. AAA资源的前六位是<br><img src="/2021/120454815/42.png" alt=" "><br>09. 脚本  </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rtf &#x3D; &#39;&#123;\\rtf1&#39; \\需要注意，\r需要转义，变成\\rA &#x3D; [0x05, 0x7D, 0x41, 0x15, 0x26, 0x01]password&#x3D;&#39;&#39;for i in range(len(rtf)):    x &#x3D; ord(rtf[i]) ^ A[i]    password+&#x3D;chr(x)print(password)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后我们将程序运行将密码输入即可，两端密码输入完后，就会在程序所在文件夹中生成一个带有flag的rtf文件，打开就能得到flag  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向常见壳</title>
      <link href="/2021/120329596.html"/>
      <url>/2021/120329596.html</url>
      
        <content type="html"><![CDATA[<p>#逆向常见壳  </p><ol><li>加壳目的  <ul><li>隐藏文件作者的个人信息或者相关不应该暴露的信息  </li><li>压缩文件，加壳之后文件的体积会变小  </li><li>有些黑客会使用壳来防止自己在文件中加入的病毒等东西被杀毒软件找到杀掉  </li></ul></li><li>常见壳的类型  <ul><li>压缩壳  </li><li>保护壳  </li><li>捆绑壳  </li></ul></li><li>压缩壳  <ul><li>upx加壳或脱壳  <ul><li>加壳原理: 首先将程序压缩。所谓的压缩包括两方面，一方面在程序的开头或者其他合适的地方 插入一段代码，另一方面是将程序的其他地方做压缩。压缩也可以叫做加密，因为压缩后的程序比较难看懂，主要是 和原来的代码有很大的不同。最大的表现也就是他的主要作用就是程序本身变小了。变小之后的程序在传输方面有很 大的优势。其次就是在程序执行时，实时的对程序解压缩  </li><li>加壳格式:<br>最初代码的形式就应该是:7==&gt;8==&gt;9==&gt;5==&gt;6<br>用upx压缩之后形式为：1==&gt;2==&gt;3==&gt;4==&gt;5==&gt;6<br>执行时的形式变为：1==&gt;7==&gt;8==&gt;9==&gt;5==&gt;6(其中1是upx插入的代码，2,3,4是文件代码,5,6随意)  </li><li>加壳解壳工具:<br>加壳：upx shell，也可以下载upx，在命令行中该目录下使用命令:upx 文件名 进行加壳操作<br>解壳：upx unpacker，也可以也可以下载upx，在命令行中该目录下使用命令:upx -d 文件名 进行解壳操作(我常用方式)，也可以进行手动解壳(太难，不建议使用，如果是大佬请忽略)  </li><li>示例：<br>upx加壳操作<br><img src="/2021/120329596/1.png"><br>upx解壳操作<br><img src="/2021/120329596/2.png"><br>手动解壳(待补充!!!)<br><a href="https://upx.github.io/">upx下载地址</a>  </li></ul></li><li>ASPack壳  <ul><li>ASPack壳也是压缩壳，加壳原理与upx相同  </li><li>加壳解壳工具:<br>加壳:ASPack<br>解壳:ASPack UnPacker  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>PECompact壳  <ul><li>PECompact壳也是压缩壳，加壳原理与upx相同  </li><li>加壳解壳工具:<br>加壳:PECompact_v3.02.2_Final.7z<br>解壳:Unpacker_PECompact.7z  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>RLPack壳  <ul><li>RLPack壳也是压缩壳，加壳原理与upx相同  </li><li>加壳解壳工具:<br>加壳:()<br>解壳:Rlpack 1.2x_Unpacker_V0.3_Final.rar  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>NsPack壳  <ul><li>NsPack壳也是压缩壳，加壳原理与upx相同  </li><li>加壳解壳工具:<br>加壳:NsPack<br>解壳:NsPack strripter 3.x  </li><li>示例:(未遇到，待补充)  </li></ul></li></ul></li><li>保护壳  <ul><li>ASProtect壳    <ul><li>加壳解壳工具:<br>加壳:ASProtect.SKE.v2.51.build.09.22.beta-RES-incl-kg.7z<br>解壳:ASProtect Unpacker.rar  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>Armadillo壳    <ul><li>加壳解壳工具:<br>加壳:<br>解壳:  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>EXECryptor壳    <ul><li>加壳解壳工具:<br>加壳:()<br>解壳:Unpacker ExeCryptor 2.x.x v1.0 RC2.zip  </li><li>示例:(未遇到，待补充)  </li></ul></li><li>Themida壳    <ul><li>加壳解壳工具:<br>加壳:Themida_x32_x64_v3.0.4.0_Repacked.rar<br>解壳:Themida&amp;winlicense UnPacKer v2.0.rar  </li><li>示例:(未遇到，待补充)   </li></ul></li><li>VMProtect壳    <ul><li>加壳解壳工具:<br>VMProtect_Professional_v2.13.8.rar  </li><li>示例:(未遇到，待补充)   </li></ul></li></ul></li><li>捆绑壳  <ul><li>MoleBox壳  <ul><li>加壳解壳工具:<br>加壳:<br>解壳: Molebox_Virtualization_Studio_unpacker </li><li>示例:(未遇到，待补充)   </li></ul></li></ul></li><li>补充说明:<br> <a href="https://www.52pojie.cn/">以上部分加壳解壳工具下载地址</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向中的一些基础</title>
      <link href="/2021/112836631.html"/>
      <url>/2021/112836631.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="strcmp-函数"><a href="#strcmp-函数" class="headerlink" title="strcmp()函数"></a>strcmp()函数</h3><ol><li>strcmp()函数采用两个char数组或字符串参数<br>格式：int strcmp (const char* str1, const char* str2)：第一个字符串或char数组，将与第二个字符串或char数组进行比较。 const主要用于防止更改给定的char数组指针。<br>返回值：str1&gt;str2–&gt;正整数;str1 &lt; str2 –&gt;负整数;str1 = str2 –&gt;0  </li><li>例如  </li><li>char str1[] = “abcd”, str2[] = “aBcd”：第一个字符串较大，并返回一个正整数，该整数是字符的值;第二个字符串较大，并返回一个负整数，该整数是字符的值；相同则会返回0。  </li><li>!strcmp(s, enflag)：比较s和enflag的字符串，相同就符合条件。（！后面跟着的数，不论正负，只要！过后就是0，而如果！后面的值是0的话，那么！0就是1了。）  </li></ol><h3 id="chr-函数"><a href="#chr-函数" class="headerlink" title="chr()函数"></a>chr()函数</h3><ol><li>chr()函数从指定ASCII码返回字符  </li><li>ASCII值可以为十进制值,八进制值(前置加0),十六进制值(前置加0x)。  </li></ol><h3 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h3><ol><li>格式：size_t strlen( const char *string )  </li><li>返回值是类型是size_t类型(长度)，strlen是不会计算\0的长度的，strlen函数遇到\0就会停止下来。  </li></ol><h3 id="isalpha-函数"><a href="#isalpha-函数" class="headerlink" title="isalpha()函数"></a>isalpha()函数</h3><ol><li>isalpha(ch):判断 字符ch是否为英文字母，当ch为英文字母a-z或A-Z时，在标准c中相当于使用“ isupper(ch)||islower(ch)”做测试，返回非零值(不一定是1)，否则返回零  </li><li>使用:chr(x).isalpha():python中用于判断  </li><li>islower（测试 字符是否为小写字母）  </li></ol><h3 id="strcat-函数"><a href="#strcat-函数" class="headerlink" title="strcat()函数"></a>strcat()函数</h3><p>strcat(a,”b”):将b处所代表的字符串附加到a里面  </p><h3 id="atoi-函数"><a href="#atoi-函数" class="headerlink" title="atoi()函数"></a>atoi()函数</h3><p>C 库函数 int atoi(const char *str) 把参数 str 所指向的字符串转换为一个整数（类型为 int 型）  </p><h3 id="FindResource-函数"><a href="#FindResource-函数" class="headerlink" title="FindResource()函数"></a>FindResource()函数</h3><ol><li>格式<br>HRSRC FindResource（HMODULE hModule，LPCTSTR lpName，LPCTSTR lpType）  </li><li>参数说明  </li></ol><ul><li>hModule：处理包含资源的可执行文件的模块。NULL值则指定模块句柄指向操作系统通常情况下创建最近过程的相关位图文件。  </li><li>lpName：指定资源名称。  </li><li>lpType：指定资源类型。作为标准资源类型。这个参数的含义同EnumResLangProclpType。  </li><li>返回值：如果函数运行成功，那么返回值为指向被指定资源信息块的句柄。为了获得这些资源，将这个句柄传递给LoadResource函数。如果函数运行失败，则返回值为NULL。若想获得更多错误信息，请调用GetLastError函数。  </li></ul><h2 id="IDA反汇编失败–call-analysis-failed"><a href="#IDA反汇编失败–call-analysis-failed" class="headerlink" title="IDA反汇编失败–call analysis failed"></a>IDA反汇编失败–call analysis failed</h2><h3 id="原因-可能是"><a href="#原因-可能是" class="headerlink" title="原因(可能是)"></a>原因(可能是)</h3><ul><li>IDA无法识别出正确的调用约定(calling convention)  </li><li>IDA无法识别出正确的参数个数  </li></ul><h3 id="IDA无法识别出正确的调用约定-calling-convention"><a href="#IDA无法识别出正确的调用约定-calling-convention" class="headerlink" title="IDA无法识别出正确的调用约定(calling convention)"></a>IDA无法识别出正确的调用约定(calling convention)</h3><p><img src="/2021/112836631/1.png" alt=" "><br>这个时候我们只要去出错位置分析就好了，看看是什么问题导致的<br><img src="/2021/112836631/2.png" alt=" "><br>在该位置可以判断参数参数正确，那就是ida无法识别正确的调用约定，这时候我们只要双击进入该函数，进行一下反汇编，之后在对main进行反汇编就可以了  </p><h3 id="IDA无法识别出正确的参数个数"><a href="#IDA无法识别出正确的参数个数" class="headerlink" title="IDA无法识别出正确的参数个数"></a>IDA无法识别出正确的参数个数</h3><p><img src="/2021/112836631/3.png" alt=" "><br>这个时候我们只要去出错位置分析就好了，看看是什么问题导致的<br><img src="/2021/112836631/4.png" alt=" "><br><img src="/2021/112836631/5.png" alt=" "><br>经分析可以知道该函数在该位置仅仅调用了两个函数，虽然0x50bf81这个地址ida反汇编中有9个，但是明显不符合要求<br><img src="/2021/112836631/6.png" alt=" "><br>这时候我们只要对该函数按’y’键，将其参数修改为两个，即可正常反编译  </p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="LOWORD"><a href="#LOWORD" class="headerlink" title="LOWORD"></a>LOWORD</h3><ol><li>格式<br>#define LOWORD(l) ((WORD)((DWORD_PTR)(l) &amp; 0xffff))  </li><li>含义<br>取低16位的宏LOWORD使用按位与操作符与数字0xffff运算，而数字0xffff是一个低16位全为1的数字，那么对其位与操作可以得到参数的低16位  </li></ol><h3 id="HIWORD"><a href="#HIWORD" class="headerlink" title="HIWORD"></a>HIWORD</h3><ol><li>格式<br>#define HIWORD(l) ((WORD)((DWORD_PTR)(l) &gt;&gt; 16))  </li><li>含义<br>取高16位的宏HIWORD，只需将参数右移16位，剩下的就是原高16位的值  </li><li>总结<br>二者都是windef.h头文件中的定义</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/112316107.html"/>
      <url>/2021/112316107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
