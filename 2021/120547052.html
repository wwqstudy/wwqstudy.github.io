<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="密码类型及加密解密算法, wwqstudy">
    <meta name="description" content="现代密码对称加密算法对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。就是明文加密和密文解密用的是同一种秘钥例如:  
rc4加密算法
说明：rc4加密是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>密码类型及加密解密算法 | wwqstudy</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">wwqstudy</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">wwqstudy</div>
        <div class="logo-desc">
            
            绘一纸潇湘，花盏玲珑如妆，雨落弦响，陌上芳华，醉影照天长
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">密码类型及加密解密算法</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-12-05
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    44 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="现代密码"><a href="#现代密码" class="headerlink" title="现代密码"></a>现代密码</h2><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。就是明文加密和密文解密用的是同一种秘钥<br>例如:  </p>
<h4 id="rc4加密算法"><a href="#rc4加密算法" class="headerlink" title="rc4加密算法"></a>rc4加密算法</h4><ol>
<li>说明：rc4加密是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密，同时密钥的长度是可以变的，对于现在仍然有很强的保护性  </li>
<li>原理：根据明文和密钥生成相应的密钥流，密钥流的长度和明文的长度是对应的，也就是说明文的长度是500字节，那么密钥流也是500字节。当然，加密生成的密文也是500字节，因为密文第i字节=明文第i字节^密钥流第i字节。而生成密钥流需要用到状态向量（S），临时向量（T），密钥（K）即：  <ul>
<li>状态向量S：长度为256，S[0],S[1]…..S[255]。每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换  </li>
<li>临时向量T：长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T  </li>
<li>密钥K：长度为1-256字节，注意密钥的长度keylen与明文长度、密钥流的长度没有必然关系，通常密钥的长度趣味16字节（128比特）  <ul>
<li>初始化S和T<br>for i in range(256) :<br>s[i] = i<br>T[i]=Key[i%len(key)] (key是密钥)  </li>
<li>初始排列S<br>j = 0<br>for i in range(256) :<br>j = (j + s[i] + T[i]) % 256<br>s[i], s[j] = s[j], s[i]  </li>
<li>产生密钥流K<br>i = 0<br>j = 0<br>for r in range(len(message)) :<br>i = (i + 1) % 256<br>j = (j + s[i]) % 256<br>s[i], s[j] = s[j], s[i]<br>t = (S[i] + S[j]) % 256<br>K[t] = S[t] (K即是密钥流)  </li>
<li>脚本：  </li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def encrypt(tmp, message):  
    tmp &#x3D; list(map(lambda x: ord(x), tmp))  
    message &#x3D; list(map(lambda x: ord(x), message))   
    S &#x3D; list(range(0, 256))  
    key &#x3D; []  # 存储秘钥流  
    T &#x3D; []  # 临时向量T   
    while len(T) &lt; 256:  
        T.extend(tmp)  
    while len(T) !&#x3D; 256:  
        T.pop()   
    j &#x3D; 0  
    for i in range(0, 256):  
        j &#x3D; (j + S[i] + T[i]) % 256  
        S[i], S[j] &#x3D; S[j], S[i]   
    i, j &#x3D; 0, 0  
    for i in range(len(message)):  
        i &#x3D; (i + 1) % 256  
        j &#x3D; (j + S[i]) % 256  
        S[i], S[j] &#x3D; S[j], S[i]  
        t &#x3D; (S[i] + S[j]) % 256  
        key.append(S[t])   
    secretary &#x3D; list(map(lambda x, y: chr(x ^ y), message, key))  
    return secretary, key  
def decrypt(secretary, key):  
    message &#x3D; list(map(lambda x, y: chr((ord(x)) ^ y), secretary, key))  
    return &#39;&#39;.join(message)  
if __name__ &#x3D;&#x3D; &#39;__main__&#39;:  
    t &#x3D; list(input(&quot;请输入初始秘钥：&quot;))  
    m &#x3D; list(input(&quot;请输入需要加密的明文：&quot;))  
    s, k &#x3D; encrypt(t, m)  
    print(encrypt(t, m)) # t即为所求 
    print(&#39;经过加密解密后得到的明文：&#39;, decrypt(s, k))  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h4><ol>
<li>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：<br><img src="/2021/120547052/1.png" alt=" "><br>轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。上面说到，AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。   AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：<br> <img src="/2021/120547052/2.png" alt=" "><br> 其主要加密如下(10次加密图)：<br> <img src="/2021/120547052/3.png" alt=" "><br> 其中:  <ul>
<li>K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。  </li>
</ul>
</li>
</ol>
<ul>
<li>字节代换：  </li>
</ul>
<ol>
<li><p>AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒。<br>AES的S盒：<br><img src="/2021/120547052/4.png" alt=" "><br>状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。<br>逆字节代换也就是查逆S盒来变换，逆S盒如下：<br><img src="/2021/120547052/5.png" alt=" ">  </p>
</li>
<li><p>计算方式进行字节代换<br>AES算法中定义的加法和乘法<br>加法：两个字节相加，其和为两个字节按比特异或的结果<br>乘法：两个字节相乘，其积为对应多项式的乘积模二元域GF(2)上的8次不可约多项式m(x)==x^8⊕x^4⊕x^3⊕x⊕1后的结果所对应的字节<br>例如：<br><img src="/2021/120547052/47.png" alt=" "><br>再者<br><img src="/2021/120547052/48.png" alt=" ">  </p>
</li>
</ol>
<ul>
<li>行移位<br>行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节<br>行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节  </li>
<li>列混合<br>列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：<br><img src="/2021/120547052/6.png" alt=" "><br>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：<br><img src="/2021/120547052/7.png" alt=" "><br>其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。<br>逆向列混合变换可由下图的矩阵乘法定义：<br><img src="/2021/120547052/8.png" alt=" "></li>
<li>轮密钥加<br>轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算；轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。  </li>
<li>密钥扩展<br>AES首先将初始密钥输入到一个44的状态矩阵中，如下图所示。<br><img src="/2021/120547052/9.png" alt=" "><br>这个44矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为”abcdefghijklmnop”,则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生：1.如果i不是4的倍数，那么第i列由如下等式确定：W[i]=W[i-4]⨁W[i-1]2.如果i是4的倍数，那么第i列由如下等式确定：W[i]=W[i-4]⨁T(W[i-1])其中，T是一个有点复杂的函数。函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。a.字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。b.字节代换：对字循环的结果使用S盒进行字节代换。c.轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。轮常量Rcon[j]是一个字，其值见下表。<br><img src="/2021/120547052/10.png" alt=" ">  </li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">下面举个例子：
设初始的128位密钥为：
3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD
那么4个初始值为：
W[0] &#x3D; 3C A1 0B 21
W[1] &#x3D; 57 F0 19 16
W[2] &#x3D; 90 2E 13 80
W[3] &#x3D; AC C1 07 BD
下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。
由于4是4的倍数，所以：
W[4] &#x3D; W[0] ⨁ T(W[3])
T(W[3])的计算步骤如下：

循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC;
将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91;
将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])&#x3D;79 C5 7A 91，故
W[4] &#x3D; 3C A1 0B 21 ⨁ 79 C5 7A 91 &#x3D; 45 64 71 B0
其余的3个子密钥段的计算如下：
W[5] &#x3D; W[1] ⨁ W[4] &#x3D; 57 F0 19 16 ⨁ 45 64 71 B0 &#x3D; 12 94 68 A6
W[6] &#x3D; W[2] ⨁ W[5] &#x3D;90 2E 13 80 ⨁ 12 94 68 A6 &#x3D; 82 BA 7B 26
W[7] &#x3D; W[3] ⨁ W[6] &#x3D; AC C1 07 BD ⨁ 82 BA 7B 26 &#x3D; 2E 7B 7C 9B
所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="TEA加密算法"><a href="#TEA加密算法" class="headerlink" title="TEA加密算法"></a>TEA加密算法</h4><ol>
<li>原理<br>TEA（Tiny Encryption Algorithm）是一种分组加密算法，它的实现非常简单，通常只需要很精短的几行代码。TEA算法使用64位的明文分组和128位的密钥，它使用Feistel分组加密框架，需要进行 64 轮迭代，尽管作者认为 32 轮已经足够了。该算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 0×9E3779B9）  </li>
<li>代码实现  </li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;Windows.h&gt;

void Encrypt(long* EntryData, long* Key)
&#123;
    &#x2F;&#x2F;分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组
    unsigned long x &#x3D; EntryData[0];
    unsigned long y &#x3D; EntryData[1];

    unsigned long sum &#x3D; 0;
    unsigned long delta &#x3D; 0x9E3779B9;
    &#x2F;&#x2F;总共加密32轮
    for (int i &#x3D; 0; i &lt; 32; i++)
    &#123;
        sum +&#x3D; delta;
        x +&#x3D; ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);
        y +&#x3D; ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);
    &#125;
    &#x2F;&#x2F;最后加密的结果重新写入到数组中
    EntryData[0] &#x3D; x;
    EntryData[1] &#x3D; y;
&#125;

void Decrypt(long* EntryData, long* Key)
&#123;
    &#x2F;&#x2F;分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组
    unsigned long x &#x3D; EntryData[0];
    unsigned long y &#x3D; EntryData[1];

    unsigned long sum &#x3D; 0;
    unsigned long delta &#x3D; 0x9E3779B9;
    sum &#x3D; delta &lt;&lt; 5;   &#x2F;&#x2F;注意这里,sum &#x3D; 32轮之后的黄金分割值. 因为我们要反序解密.
    &#x2F;&#x2F;总共加密32轮 那么反序也解密32轮
    for (int i &#x3D; 0; i &lt; 32; i++)
    &#123;

        &#x2F;&#x2F; 先将y解开 然后参与运算在解x
        y -&#x3D; ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]);
        x -&#x3D; ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]);
        sum -&#x3D; delta;
    &#125;
    &#x2F;&#x2F;最后加密的结果重新写入到数组中
    EntryData[0] &#x3D; x;
    EntryData[1] &#x3D; y;
&#125;

int main()
&#123;



    long Data[3] &#x3D; &#123; 0x44434241,0x48474645,0x0 &#125;;
    printf(&quot;待加密的数值 &#x3D; %s\r\n&quot;, (char*)Data);

    long key[4] &#x3D; &#123; 0x11223344,0x55667788,0x99AABBCC,0xDDEEFF11 &#125;;

    &#x2F;&#x2F;Encrypt每次只是加密4字节数组中的两组(也就是每次加密8个字节) 如果你数据多.可以来个for循环来循环加密,但是Entrypt内部还有32次循环,所以速度上还是会有点影响.
    Encrypt(Data, key);
    printf(&quot;加密后的数值 &#x3D; %s\r\n&quot;, (char*)Data);
    Decrypt(Data, key);
    printf(&quot;解密后的数值 &#x3D; %s\r\n&quot;, (char*)Data);
    system(&quot;pause&quot;);
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="XTEA机密算法"><a href="#XTEA机密算法" class="headerlink" title="XTEA机密算法"></a>XTEA机密算法</h4><ol>
<li>原理<br>与TEA加密算法类似，只是增加了更多的密钥表，移位和异或操作等等。  </li>
<li>代码实现  </li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;  
#include &lt;stdint.h&gt;  

void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  
    unsigned int i;  
    uint32_t v0&#x3D;v[0], v1&#x3D;v[1], sum&#x3D;0, delta&#x3D;0x9E3779B9;  
    for (i&#x3D;0; i &lt; num_rounds; i++) &#123;  
        v0 +&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  
        sum +&#x3D; delta;  
        v1 +&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  
    &#125;  
    v[0]&#x3D;v0; v[1]&#x3D;v1;  
&#125;  

void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123;  
    unsigned int i;  
    uint32_t v0&#x3D;v[0], v1&#x3D;v[1], delta&#x3D;0x9E3779B9, sum&#x3D;delta*num_rounds;  
    for (i&#x3D;0; i &lt; num_rounds; i++) &#123;  
        v1 -&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);  
        sum -&#x3D; delta;  
        v0 -&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);  
    &#125;  
    v[0]&#x3D;v0; v[1]&#x3D;v1;  
&#125;  

int main()  
&#123;  
    uint32_t v[2]&#x3D;&#123;1,2&#125;;  
    uint32_t const k[4]&#x3D;&#123;2,2,3,4&#125;;  
    unsigned int r&#x3D;32;&#x2F;&#x2F;num_rounds建议取值为32  
    &#x2F;&#x2F; v为要加密的数据是两个32位无符号整数  
    &#x2F;&#x2F; k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位  
    printf(&quot;加密前原始数据：%u %u\n&quot;,v[0],v[1]);  
    encipher(r, v, k);  
    printf(&quot;加密后的数据：%u %u\n&quot;,v[0],v[1]);  
    decipher(r, v, k);  
    printf(&quot;解密后的数据：%u %u\n&quot;,v[0],v[1]);  
    return 0;  
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="XXTEA加密算法"><a href="#XXTEA加密算法" class="headerlink" title="XXTEA加密算法"></a>XXTEA加密算法</h4><ol>
<li>原理<br><img src="/2021/120547052/13.png" alt=" ">  </li>
<li>代码实现  </li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;  
#include &lt;stdint.h&gt;  
#define DELTA 0x9e3779b9  
#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))  

void btea(uint32_t *v, int n, uint32_t const key[4])  
&#123;  
    uint32_t y, z, sum;  
    unsigned p, rounds, e;  
    if (n &gt; 1)            &#x2F;* Coding Part *&#x2F;  
    &#123;  
        rounds &#x3D; 6 + 52&#x2F;n;  
        sum &#x3D; 0;  
        z &#x3D; v[n-1];  
        do  
        &#123;  
            sum +&#x3D; DELTA;  
            e &#x3D; (sum &gt;&gt; 2) &amp; 3;  
            for (p&#x3D;0; p&lt;n-1; p++)  
            &#123;  
                y &#x3D; v[p+1];  
                z &#x3D; v[p] +&#x3D; MX;  
            &#125;  
            y &#x3D; v[0];  
            z &#x3D; v[n-1] +&#x3D; MX;  
        &#125;  
        while (--rounds);  
    &#125;  
    else if (n &lt; -1)      &#x2F;* Decoding Part *&#x2F;  
    &#123;  
        n &#x3D; -n;  
        rounds &#x3D; 6 + 52&#x2F;n;  
        sum &#x3D; rounds*DELTA;  
        y &#x3D; v[0];  
        do  
        &#123;  
            e &#x3D; (sum &gt;&gt; 2) &amp; 3;  
            for (p&#x3D;n-1; p&gt;0; p--)  
            &#123;  
                z &#x3D; v[p-1];  
                y &#x3D; v[p] -&#x3D; MX;  
            &#125;  
            z &#x3D; v[n-1];  
            y &#x3D; v[0] -&#x3D; MX;  
            sum -&#x3D; DELTA;  
        &#125;  
        while (--rounds);  
    &#125;  
&#125;  


int main()  
&#123;  
    uint32_t v[2]&#x3D; &#123;1,2&#125;;  
    uint32_t const k[4]&#x3D; &#123;2,2,3,4&#125;;  
    int n&#x3D; 2; &#x2F;&#x2F;n的绝对值表示v的长度，取正表示加密，取负表示解密  
    &#x2F;&#x2F; v为要加密的数据是两个32位无符号整数  
    &#x2F;&#x2F; k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位  
    printf(&quot;加密前原始数据：%u %u\n&quot;,v[0],v[1]);  
    btea(v, n, k);  
    printf(&quot;加密后的数据：%u %u\n&quot;,v[0],v[1]);  
    btea(v, -n, k);  
    printf(&quot;解密后的数据：%u %u\n&quot;,v[0],v[1]);  
    return 0;  
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="DES加密算法"><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h4><ol>
<li>原理<br>利用一些简单的密码变换，如：代换、置换、加减等设计出一个圈函数f，并通过将他多次迭代的方法，产生的一个分组密码算法  </li>
<li>基本参数<br>分组长度：64bit<br>密钥长度：64bit<br>有效密钥长度：56bit(每8bit的最高位是校验码，检验错误)<br>迭代的圈数：16圈<br>圈密钥的长度：48bit  </li>
<li>加密完整的流程图<br><img src="/2021/120547052/36.png" alt=" ">  </li>
<li>解析  </li>
</ol>
<ul>
<li>初始置换IP和逆初始置换IP-1<br><img src="/2021/120547052/37.png" alt=" "><br>其中：初始置换中的数字序号代表的是最初给定的数字的序号，而逆初始置换中的数字是经过一系列操作之后现在得到的结果进行从开始进行从新排序之后的数字编号  </li>
<li>迭代16圈<br>前15圈的算法结构可以表示为：(Li,Ri)=(Ri-1,Li-1⊕f(Ri-1, Ki))<br>第16圈的算法结构可以表示为：(L16,R16)=(L15⊕f(R15,K16),R16)  </li>
<li>f函数解析  </li>
</ul>
<ol>
<li>f函数图解<br><img src="/2021/120547052/38.png" alt=" ">  </li>
<li>E盒扩展<br>目的：将输入的32bit数据扩展为48bit数据<br><img src="/2021/120547052/39.png" alt=" "><br>扩展方式解析：(1) 将输入的32比特每4比特为一组分为8块;<br>（2）分别将第m-1块的最右比特和第m+1块的最左比特添到第m块的左边和右边,形成输出的第k个6比特块  </li>
<li>S盒代换<br>目的：将输入的48bit数据压缩为32bit数据<br><img src="/2021/120547052/40.png" alt=" "><br>举例：<br><img src="/2021/120547052/41.png" alt=" ">  </li>
<li>P盒变换<br>目的：对S盒变换后的32比特数据的位置进行移动<br><img src="/2021/120547052/42.png" alt=" "><br>特点：（1）P盒的各输入块的4个比特都分配到不同的输出块之中<br>（2）P盒的各输出块的4个比特都来自不同的输入块<br>（3）P盒的第t输出块的4个比特都不来自第t输入块  </li>
</ol>
<ul>
<li>DES的圈密钥生成算法  </li>
</ul>
<ol>
<li>圈密钥生成算法图解<br><img src="/2021/120547052/43.png" alt=" ">  </li>
<li>置换选择1<br><img src="/2021/120547052/44.png" alt=" "><br>其中：将每8个bit的最高位的检验位去除，之后按照图表进行排序  </li>
<li>置换选择2<br><img src="/2021/120547052/45.png" alt=" "><br>其中：该序号时将进行操作之后的数据从新编号之后，按图表编号在取出数据  </li>
<li>移位情况<br><img src="/2021/120547052/46.png" alt=" ">  </li>
</ol>
<ul>
<li>解密情况<br>解密和加密的算法结构完全相同<br>密钥顺序相反  </li>
<li>加密解密算法  </li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*************************************************************************
    &gt; File Name: Des.cpp
    &gt; Author: SongLee
    &gt; E-mail: lisong.shine@qq.com
    &gt; Created Time: 2014年06月01日 星期日 19时46分32秒
    &gt; Personal Blog: http:&#x2F;&#x2F;songlee24.github.com
************************************************************************&#x2F;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;bitset&gt;
#include &lt;string&gt;
using namespace std;

bitset&lt;64&gt; key;                &#x2F;&#x2F; 64位密钥
bitset&lt;48&gt; subKey[16];         &#x2F;&#x2F; 存放16轮子密钥

&#x2F;&#x2F; 初始置换表
int IP[] &#x3D; &#123;58, 50, 42, 34, 26, 18, 10, 2,
            60, 52, 44, 36, 28, 20, 12, 4,
            62, 54, 46, 38, 30, 22, 14, 6,
            64, 56, 48, 40, 32, 24, 16, 8,
            57, 49, 41, 33, 25, 17, 9,  1,
            59, 51, 43, 35, 27, 19, 11, 3,
            61, 53, 45, 37, 29, 21, 13, 5,
            63, 55, 47, 39, 31, 23, 15, 7&#125;;

&#x2F;&#x2F; 结尾置换表
int IP_1[] &#x3D; &#123;40, 8, 48, 16, 56, 24, 64, 32,
            39, 7, 47, 15, 55, 23, 63, 31,
            38, 6, 46, 14, 54, 22, 62, 30,
            37, 5, 45, 13, 53, 21, 61, 29,
            36, 4, 44, 12, 52, 20, 60, 28,
            35, 3, 43, 11, 51, 19, 59, 27,
            34, 2, 42, 10, 50, 18, 58, 26,
            33, 1, 41,  9, 49, 17, 57, 25&#125;;

&#x2F;*------------------下面是生成密钥所用表-----------------*&#x2F;

&#x2F;&#x2F; 密钥置换表，将64位密钥变成56位
int PC_1[] &#x3D; &#123;57, 49, 41, 33, 25, 17, 9,
            1, 58, 50, 42, 34, 26, 18,
            10,  2, 59, 51, 43, 35, 27,
            19, 11,  3, 60, 52, 44, 36,
            63, 55, 47, 39, 31, 23, 15,
            7, 62, 54, 46, 38, 30, 22,
            14,  6, 61, 53, 45, 37, 29,
            21, 13,  5, 28, 20, 12,  4&#125;;

&#x2F;&#x2F; 压缩置换，将56位密钥压缩成48位子密钥
int PC_2[] &#x3D; &#123;14, 17, 11, 24,  1,  5,
            3, 28, 15,  6, 21, 10,
            23, 19, 12,  4, 26,  8,
            16,  7, 27, 20, 13,  2,
            41, 52, 31, 37, 47, 55,
            30, 40, 51, 45, 33, 48,
            44, 49, 39, 56, 34, 53,
            46, 42, 50, 36, 29, 32&#125;;

&#x2F;&#x2F; 每轮左移的位数
int shiftBits[] &#x3D; &#123;1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1&#125;;

&#x2F;*------------------下面是密码函数 f 所用表-----------------*&#x2F;

&#x2F;&#x2F; 扩展置换表，将 32位 扩展至 48位
int E[] &#x3D; &#123;32,  1,  2,  3,  4,  5,
            4,  5,  6,  7,  8,  9,
            8,  9, 10, 11, 12, 13,
        12, 13, 14, 15, 16, 17,
        16, 17, 18, 19, 20, 21,
        20, 21, 22, 23, 24, 25,
        24, 25, 26, 27, 28, 29,
        28, 29, 30, 31, 32,  1&#125;;

&#x2F;&#x2F; S盒，每个S盒是4x16的置换表，6位 -&gt; 4位
int S_BOX[8][4][16] &#x3D; &#123;
    &#123;
        &#123;14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7&#125;,
        &#123;0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8&#125;,
        &#123;4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0&#125;,
        &#123;15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13&#125;
    &#125;,
    &#123;
        &#123;15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10&#125;,
        &#123;3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5&#125;,
        &#123;0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15&#125;,
        &#123;13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9&#125;
    &#125;,
    &#123;
        &#123;10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8&#125;,
        &#123;13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1&#125;,
        &#123;13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7&#125;,
        &#123;1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12&#125;
    &#125;,
    &#123;
        &#123;7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15&#125;,
        &#123;13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9&#125;,
        &#123;10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4&#125;,
        &#123;3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14&#125;
    &#125;,
    &#123;
        &#123;2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9&#125;,
        &#123;14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6&#125;,
        &#123;4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14&#125;,
        &#123;11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3&#125;
    &#125;,
    &#123;
        &#123;12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11&#125;,
        &#123;10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8&#125;,
        &#123;9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6&#125;,
        &#123;4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13&#125;
    &#125;,
    &#123;
        &#123;4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1&#125;,
        &#123;13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6&#125;,
        &#123;1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2&#125;,
        &#123;6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12&#125;
    &#125;,
    &#123;
        &#123;13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7&#125;,
        &#123;1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2&#125;,
        &#123;7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8&#125;,
        &#123;2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11&#125;
    &#125;
&#125;;

&#x2F;&#x2F; P置换，32位 -&gt; 32位
int P[] &#x3D; &#123;16,  7, 20, 21,
        29, 12, 28, 17,
            1, 15, 23, 26,
            5, 18, 31, 10,
            2,  8, 24, 14,
        32, 27,  3,  9,
        19, 13, 30,  6,
        22, 11,  4, 25 &#125;;

&#x2F;**********************************************************************&#x2F;
&#x2F;*                                                                    *&#x2F;
&#x2F;*                            下面是DES算法实现                         *&#x2F;
&#x2F;*                                                                    *&#x2F;
&#x2F;**********************************************************************&#x2F;

&#x2F;**
*  密码函数f，接收32位数据和48位子密钥，产生一个32位的输出
*&#x2F;
bitset&lt;32&gt; f(bitset&lt;32&gt; R, bitset&lt;48&gt; k)
&#123;
    bitset&lt;48&gt; expandR;
    &#x2F;&#x2F; 第一步：扩展置换，32 -&gt; 48
    for(int i&#x3D;0; i&lt;48; ++i)
        expandR[47-i] &#x3D; R[32-E[i]];
    &#x2F;&#x2F; 第二步：异或
    expandR &#x3D; expandR ^ k;
    &#x2F;&#x2F; 第三步：查找S_BOX置换表
    bitset&lt;32&gt; output;
    int x &#x3D; 0;
    for(int i&#x3D;0; i&lt;48; i&#x3D;i+6)
    &#123;
        int row &#x3D; expandR[47-i]*2 + expandR[47-i-5];
        int col &#x3D; expandR[47-i-1]*8 + expandR[47-i-2]*4 + expandR[47-i-3]*2 + expandR[47-i-4];
        int num &#x3D; S_BOX[i&#x2F;6][row][col];
        bitset&lt;4&gt; binary(num);
        output[31-x] &#x3D; binary[3];
        output[31-x-1] &#x3D; binary[2];
        output[31-x-2] &#x3D; binary[1];
        output[31-x-3] &#x3D; binary[0];
        x +&#x3D; 4;
    &#125;
    &#x2F;&#x2F; 第四步：P-置换，32 -&gt; 32
    bitset&lt;32&gt; tmp &#x3D; output;
    for(int i&#x3D;0; i&lt;32; ++i)
        output[31-i] &#x3D; tmp[32-P[i]];
    return output;
&#125;

&#x2F;**
*  对56位密钥的前后部分进行左移
*&#x2F;
bitset&lt;28&gt; leftShift(bitset&lt;28&gt; k, int shift)
&#123;
    bitset&lt;28&gt; tmp &#x3D; k;
    for(int i&#x3D;27; i&gt;&#x3D;0; --i)
    &#123;
        if(i-shift&lt;0)
            k[i] &#x3D; tmp[i-shift+28];
        else
            k[i] &#x3D; tmp[i-shift];
    &#125;
    return k;
&#125;

&#x2F;**
*  生成16个48位的子密钥
*&#x2F;
void generateKeys()
&#123;
    bitset&lt;56&gt; realKey;
    bitset&lt;28&gt; left;
    bitset&lt;28&gt; right;
    bitset&lt;48&gt; compressKey;
    &#x2F;&#x2F; 去掉奇偶标记位，将64位密钥变成56位
    for (int i&#x3D;0; i&lt;56; ++i)
        realKey[55-i] &#x3D; key[64 - PC_1[i]];
    &#x2F;&#x2F; 生成子密钥，保存在 subKeys[16] 中
    for(int round&#x3D;0; round&lt;16; ++round)
    &#123;
        &#x2F;&#x2F; 前28位与后28位
        for(int i&#x3D;28; i&lt;56; ++i)
            left[i-28] &#x3D; realKey[i];
        for(int i&#x3D;0; i&lt;28; ++i)
            right[i] &#x3D; realKey[i];
        &#x2F;&#x2F; 左移
        left &#x3D; leftShift(left, shiftBits[round]);
        right &#x3D; leftShift(right, shiftBits[round]);
        &#x2F;&#x2F; 压缩置换，由56位得到48位子密钥
        for(int i&#x3D;28; i&lt;56; ++i)
            realKey[i] &#x3D; left[i-28];
        for(int i&#x3D;0; i&lt;28; ++i)
            realKey[i] &#x3D; right[i];
        for(int i&#x3D;0; i&lt;48; ++i)
            compressKey[47-i] &#x3D; realKey[56 - PC_2[i]];
        subKey[round] &#x3D; compressKey;
    &#125;
&#125;

&#x2F;**
*  工具函数：将char字符数组转为二进制
*&#x2F;
bitset&lt;64&gt; charToBitset(const char s[8])
&#123;
    bitset&lt;64&gt; bits;
    for(int i&#x3D;0; i&lt;8; ++i)
        for(int j&#x3D;0; j&lt;8; ++j)
            bits[i*8+j] &#x3D; ((s[i]&gt;&gt;j) &amp; 1);
    return bits;
&#125;

&#x2F;**
*  DES加密
*&#x2F;
bitset&lt;64&gt; encrypt(bitset&lt;64&gt;&amp; plain)
&#123;
    bitset&lt;64&gt; cipher;
    bitset&lt;64&gt; currentBits;
    bitset&lt;32&gt; left;
    bitset&lt;32&gt; right;
    bitset&lt;32&gt; newLeft;
    &#x2F;&#x2F; 第一步：初始置换IP
    for(int i&#x3D;0; i&lt;64; ++i)
        currentBits[63-i] &#x3D; plain[64-IP[i]];
    &#x2F;&#x2F; 第二步：获取 Li 和 Ri
    for(int i&#x3D;32; i&lt;64; ++i)
        left[i-32] &#x3D; currentBits[i];
    for(int i&#x3D;0; i&lt;32; ++i)
        right[i] &#x3D; currentBits[i];
    &#x2F;&#x2F; 第三步：共16轮迭代
    for(int round&#x3D;0; round&lt;16; ++round)
    &#123;
        newLeft &#x3D; right;
        right &#x3D; left ^ f(right,subKey[round]);
        left &#x3D; newLeft;
    &#125;
    &#x2F;&#x2F; 第四步：合并L16和R16，注意合并为 R16L16
    for(int i&#x3D;0; i&lt;32; ++i)
        cipher[i] &#x3D; left[i];
    for(int i&#x3D;32; i&lt;64; ++i)
        cipher[i] &#x3D; right[i-32];
    &#x2F;&#x2F; 第五步：结尾置换IP-1
    currentBits &#x3D; cipher;
    for(int i&#x3D;0; i&lt;64; ++i)
        cipher[63-i] &#x3D; currentBits[64-IP_1[i]];
    &#x2F;&#x2F; 返回密文
    return cipher;
&#125;

&#x2F;**
*  DES解密
*&#x2F;
bitset&lt;64&gt; decrypt(bitset&lt;64&gt;&amp; cipher)
&#123;
    bitset&lt;64&gt; plain;
    bitset&lt;64&gt; currentBits;
    bitset&lt;32&gt; left;
    bitset&lt;32&gt; right;
    bitset&lt;32&gt; newLeft;
    &#x2F;&#x2F; 第一步：初始置换IP
    for(int i&#x3D;0; i&lt;64; ++i)
        currentBits[63-i] &#x3D; cipher[64-IP[i]];
    &#x2F;&#x2F; 第二步：获取 Li 和 Ri
    for(int i&#x3D;32; i&lt;64; ++i)
        left[i-32] &#x3D; currentBits[i];
    for(int i&#x3D;0; i&lt;32; ++i)
        right[i] &#x3D; currentBits[i];
    &#x2F;&#x2F; 第三步：共16轮迭代（子密钥逆序应用）
    for(int round&#x3D;0; round&lt;16; ++round)
    &#123;
        newLeft &#x3D; right;
        right &#x3D; left ^ f(right,subKey[15-round]);
        left &#x3D; newLeft;
    &#125;
    &#x2F;&#x2F; 第四步：合并L16和R16，注意合并为 R16L16
    for(int i&#x3D;0; i&lt;32; ++i)
        plain[i] &#x3D; left[i];
    for(int i&#x3D;32; i&lt;64; ++i)
        plain[i] &#x3D; right[i-32];
    &#x2F;&#x2F; 第五步：结尾置换IP-1
    currentBits &#x3D; plain;
    for(int i&#x3D;0; i&lt;64; ++i)
        plain[63-i] &#x3D; currentBits[64-IP_1[i]];
    &#x2F;&#x2F; 返回明文
    return plain;
&#125;


&#x2F;**********************************************************************&#x2F;
&#x2F;* 测试：                                                             *&#x2F;
&#x2F;*     1.将一个 64 位的字符串加密， 把密文写入文件 a.txt                  *&#x2F;
&#x2F;*     2.读取文件 a.txt 获得 64 位密文，解密之后再写入 b.txt              *&#x2F;
&#x2F;**********************************************************************&#x2F;

int main() &#123;
    string s &#x3D; &quot;romantic&quot;;
    string k &#x3D; &quot;12345678&quot;;
    bitset&lt;64&gt; plain &#x3D; charToBitset(s.c_str());
    key &#x3D; charToBitset(k.c_str());
    &#x2F;&#x2F; 生成16个子密钥
    generateKeys();
    &#x2F;&#x2F; 密文写入 a.txt
    bitset&lt;64&gt; cipher &#x3D; encrypt(plain);
    fstream file1;
    file1.open(&quot;D:&#x2F;&#x2F;a.txt&quot;, ios::binary | ios::out);
    file1.write((char*)&amp;cipher,sizeof(cipher));
    file1.close();

    &#x2F;&#x2F; 读文件 a.txt
    bitset&lt;64&gt; temp;
    file1.open(&quot;D:&#x2F;&#x2F;a.txt&quot;, ios::binary | ios::in);
    file1.read((char*)&amp;temp, sizeof(temp));
    file1.close();

    &#x2F;&#x2F; 解密，并写入文件 b.txt
    bitset&lt;64&gt; temp_plain &#x3D; decrypt(temp);
    file1.open(&quot;D:&#x2F;&#x2F;b.txt&quot;, ios::binary | ios::out);
    file1.write((char*)&amp;temp_plain,sizeof(temp_plain));
    file1.close();

    return 0;
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="SM4加密算法"><a href="#SM4加密算法" class="headerlink" title="SM4加密算法"></a>SM4加密算法</h4><ol>
<li><p>加密解密流程图如下：<br><img src="/2021/120547052/52.png" alt=" ">  </p>
</li>
<li><p>加密  </p>
</li>
</ol>
<ul>
<li>输入的明文为 128bit 的数据将其按位拆分成 4 个 32bit 的数据x0,x1,x2,x3，当i=0 时为第一次轮变换，一直进行到 i=31 结束  </li>
<li>xi  暂时不做处理，将 xi+1,xi+2,xi+3 和轮密钥 rki 异或得到一个 32bit 的数据，作为盒变换的输入<br>即 sbox_input=xi+1⊕xi+2⊕xi+3⊕rki，⊕ 符号代表异或运算  </li>
<li>将 sbox_input 拆分成 4 个 8bit 数据，分别进行盒变换，之后再将 4 个 8bit 输出合并成一个 32bit 的 sbox_output  </li>
<li>将刚才获得的 sbox_output 分别循环左移 2，10，18，24 位，得到 4 个 32bit 的结果，记移位结果为 y2,y10,y18,y24  </li>
<li>将移位的结果 y2,y10,y18,y24 与盒变换输出 sbox_output 和 xi 异或，得到 xi+4<br>即 xi+4=sbox_output⊕y2⊕y10⊕y18⊕y24⊕xi  </li>
<li>至此完成了一轮的加解密运算<br>在实际加解密过程中，上述运算要执行 32 轮，同时使用 32 个不同的 rki，rki 由密钥拓展生成  </li>
<li>最后将生成的最后 4 个 32bit 数据 x35,x34,x33,x32 合并成一个 128bit 的数据 output，作为最后的输出结果<br>其中的盒变换的盒子如下图<br><img src="/2021/120547052/49.png" alt=" ">  </li>
</ul>
<ol>
<li>密钥拓展  </li>
</ol>
<ul>
<li>输入的原始密钥 key 为 128bit 的数据，将其按位拆分成 4 个 32bit 的数据 K0,K1,K2,K3  </li>
<li>将初始密钥 K0,K1,K2,K3 分别异或固定参数 FK0,FK1,FK2,FK3 得到用于循环的密钥 k0,k1,k2,k3<br>即 k0=K0⊕FK0,k1=K1⊕FK1,k2=K2⊕FK2,k3=K3⊕FK3  </li>
<li>进入轮密钥 rki 的生成<br>当 i=0 时为第一次轮变换，一直进行到 i=31 结束  </li>
<li>ki  暂时不做处理，将 ki+1,ki+2,ki+3 和固定参数 CKi 异或得到一个 32bit 的数据，作为盒变换的输入<br>即 sbox_input=ki+1⊕ki+2⊕ki+3⊕cki  </li>
<li>将 sbox_input 拆分成 4 个 8bit 数据，分别进行盒变换，之后再将 4 个 8bit 输出合并成一个 32bit 的 sbox_output  </li>
<li>将刚才获得的 sbox_output 分别循环左移 13，23 位，得到 2 个 32bit 的结果，记移位结果为 y13,y23  </li>
<li>将移位的结果 y13,y23 与盒变换输出 sbox_output 和 ki 异或，得到 ki+4<br>即 rki=ki+4=sbox_output⊕y13⊕y23⊕ki  </li>
<li>至此完成了一轮的加解密运算<br>在实际加解密过程中，上述运算要执行 32 轮，同时使用 32 个不同的 CKi，CKi 为固定参数  </li>
<li>执行完 32 轮后，便可获得 32 个用于加解密的 rki<br>其中要用的盒子上面有，CK和FK如下图<br>FK：<br><img src="/2021/120547052/50.png" alt=" "><br>CK:<br><img src="/2021/120547052/51.png" alt=" ">  </li>
</ul>
<h3 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol>
<li>分组密码的工作模式是指以这个分组密码为基础通过某种方式构造一个分组密码系统，以解决对任意长度明文的加密问题  </li>
</ol>
<h4 id="1电码本-ECB-模式"><a href="#1电码本-ECB-模式" class="headerlink" title="1电码本(ECB)模式"></a>1电码本(ECB)模式</h4><ol>
<li>ECB 模式是直接使用分组密码的工作模式，明文的各个分组独立地使用同一密钥 k 加密  </li>
<li>加解密框图如下：<br><img src="/2021/120547052/53.png" alt=" ">  </li>
<li>分组短块<br>直接扩充法–直接补0或者其他固定bit–添加随机数(填充的最好是可以识别身份的)<br>密文挪用法–从最后的密文开始在最后进行填充  </li>
</ol>
<h4 id="密码分组链接-CBC-模式"><a href="#密码分组链接-CBC-模式" class="headerlink" title="密码分组链接(CBC)模式"></a>密码分组链接(CBC)模式</h4><ol>
<li>加密<br><img src="/2021/120547052/54.png" alt=" ">  </li>
<li>解密<br><img src="/2021/120547052/55.png" alt=" ">  </li>
</ol>
<h4 id="密码反馈-CFB-模式"><a href="#密码反馈-CFB-模式" class="headerlink" title="密码反馈(CFB)模式"></a>密码反馈(CFB)模式</h4><ol>
<li>加密<br><img src="/2021/120547052/56.png" alt=" ">  </li>
<li>解密<br><img src="/2021/120547052/57.png" alt=" ">  </li>
</ol>
<h4 id="输出反馈-OFB-模式"><a href="#输出反馈-OFB-模式" class="headerlink" title="输出反馈(OFB)模式"></a>输出反馈(OFB)模式</h4><ol>
<li>加密<br><img src="/2021/120547052/58.png" alt=" ">  </li>
<li>解密<br><img src="/2021/120547052/59.png" alt=" ">  </li>
</ol>
<h4 id="计数器-CTR-模式"><a href="#计数器-CTR-模式" class="headerlink" title="计数器(CTR)模式"></a>计数器(CTR)模式</h4><ol>
<li>原理：利用固定密钥k对自然数序列1,2,3,…,n, …加密，将得到的密文分组序列看作乱数序列。按加减密码的方式与明文分组逐位模2加的一种方式  </li>
</ol>
<h2 id="其他密码学"><a href="#其他密码学" class="headerlink" title="其他密码学"></a>其他密码学</h2><h3 id="base加密"><a href="#base加密" class="headerlink" title="base加密"></a>base加密</h3><ol>
<li><p>原理<br>a. 将三个八位的字节转化为四个六位的字节，不足补零。它是用64个可打印字符表示二进制所有数据方法。由于2的6次方等于64，所以可以用每6个位元为一个单元，对应某个可打印字符。我们知道三个字节有24个位元，就可以刚好对应于4个Base64单元，即3个字节需要用4个Base64的可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9 ，这样共有62个字符，此外两个可打印符号在不同的系统中一般有所不同。但是，我们经常所说的Base64另外2个字符是：“+/”。这64个字符，所对应的索引表如下(索引号不是对应的ascii值)：<br><img src="/2021/120547052/11.png" alt=" "><br>b. 转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。所以加密后的数据量是原来的4/3。<br>c. 但转换的字节数不一定就是24的整数倍，会出现有多余不足六位的情况，在base64中处理的方法是加零凑够六位，但是这样一来在解码的时候就会出现多余的位，这该怎么办呢？ 不用担心，base64想到了一个很好的解决办法。<br>​d. 这个办法就是在base64凑零的同时，还要满足凑出来的位数是8的倍数，不然就加一个或者两个特殊的六位=符号。为什么是一个或者两个=符号呢？因为多个8位转为6位 只会出现剩余2位、4位的情况，剩余2位时只需要一个表示六位的=便可变为8的整数；而剩余4位 需要两个表示6位的=便可以变为8的整数。然后在解密的时候不解析=即可。<br>​之所以位的总数需要凑成8的倍数，是因为base64主要用于加密后的数据传送，而在传送机制中都认为传送的最小单位是按照字节算的，所以不能出现不是位总数不是8的倍数的情况，在接收到数据后，按顺序将6位的base64直接按照顺序解密成字节就完成解密了。<br><img src="/2021/120547052/12.png" alt=" ">  </p>
</li>
<li><p>base加密系列字母表  </p>
</li>
<li><p><strong>base16：0到9，A到F<a target="_blank" rel="noopener" href="https://www.qqxiuzi.cn/bianma/base.php?type=16">在线解密</a></strong>  </p>
</li>
<li><p><strong>base32：A到Z，2到7<a target="_blank" rel="noopener" href="https://www.qqxiuzi.cn/bianma/base.php">在线解密</a></strong>  </p>
</li>
<li><p>base36：0到9，a到z<a target="_blank" rel="noopener" href="http://ctf.ssleye.com/base36w.html">在线解密</a>  </p>
</li>
<li><p><strong>base58:1到9，a到z，A到Z<a target="_blank" rel="noopener" href="http://www.metools.info/code/c74.html">在线解密</a></strong>  </p>
</li>
<li><p><strong>base62:0到9，a到z，A到Z<a target="_blank" rel="noopener" href="http://www.atoolbox.net/Tool.php?Id=933">在线解密</a></strong>  </p>
</li>
<li><p><strong>base64:a到z，A到Z，0到9，特别地有/+（可以转图片）<a target="_blank" rel="noopener" href="https://tool.oschina.net/encrypt?type=3">在线解密</a></strong>  </p>
</li>
<li><p><strong>base91：A到Z，a到z，0到9，!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`{|}~）<a target="_blank" rel="noopener" href="http://www.atoolbox.net/Tool.php?Id=935">在线解密</a></strong>  </p>
</li>
<li><p><strong>base92：0到9，A到Z，a到z，!#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_{|｝<a target="_blank" rel="noopener" href="http://ctf.ssleye.com/base92.html">在线解密</a></strong>  </p>
</li>
<li><p><strong>base128：0到9，A到Z，a到z，\xb5\xb6\xb7\xbc\xbd\xbe\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff</strong>  </p>
</li>
</ol>
<h3 id="Hash-哈希算法"><a href="#Hash-哈希算法" class="headerlink" title="Hash(哈希算法)"></a>Hash(哈希算法)</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>特征：md5加密后是16位或者32位的字符，由字母和数字组成，字母大小写统一；<br>理论上无法解密，除非暴力破解  </p>
<h4 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h4><p>特征：SHA-1加密后的密文是40个字符，并且由数字字母组成；  </p>
<h4 id="SHA-2"><a href="#SHA-2" class="headerlink" title="SHA-2"></a>SHA-2</h4><p>特征：SHA-2 又分为两种算法，SHA-224 和 SHA-256。两者生成的密文都是由 0-9a-fA-F 组成的，其中 SHA-224 的密文长度固定是 56，SHA-256 的密文长度是 64 。  </p>
<h3 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>原理:  </p>
<ul>
<li>利用密钥K产生一个密钥流z=z0z1z2…，并使用如下规则对明文串x=x0x1x2…加密：y=y0y1y2=Ez0(x0)Ez1(x1)Ez2(x2)…  </li>
<li>密钥流由密钥流发生器产生：Z=f(k,σi),这里σi是加密器中的记忆元件（储存器）在时刻i的状态，f是由密钥k和σi产生的函数。  </li>
</ul>
<p>其他：  </p>
<ul>
<li>分组密码与流密码的区别就在于有无记忆性  </li>
<li>同步流密码概念模型如下<br><img src="/2021/120547052/13.png" alt=" ">  </li>
<li>有限状态自动机逻辑类似逻辑设计学习中的现态次态状态表  </li>
<li>密钥流产生器  </li>
</ul>
<ol>
<li>一般组成为：一个参数为K的有限状态自动机，由一个输出符号集z、一个状态集Σ、两个函数φ和ψ以及一个初始状态σ0  </li>
<li>方式：状态转移函数φ：σi-&gt;σi+1，将当前状态σi变为一个新状态σi+1，输出函数ψ:σi-&gt;Zi，当前状态σi变为输出符号集中的一个元素Zi  </li>
<li>采用方法：非线性函数的方法  </li>
<li>作为有限状态自动机的密钥流生成器和密钥流生成器分解图如下：<br><img src="/2021/120547052/14.png" alt=" ">  </li>
<li>常见的两种密钥流产生器如下图<br><img src="/2021/120547052/15.png" alt=" ">  </li>
</ol>
<h4 id="线性反馈移位寄存器"><a href="#线性反馈移位寄存器" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h4><ul>
<li>概念：移位寄存器是六密码产生密钥流的一个主要组成部分  </li>
<li>GF(2)上的n级反馈移位寄存器如下图<br><img src="/2021/120547052/16.png" alt=" ">  </li>
<li>我们常用的一般是这种：<br><img src="/2021/120547052/17.png" alt=" ">  </li>
<li>公式是：<br><img src="/2021/120547052/18.png" alt=" ">  </li>
<li>说明：其中的C1…Cn反应的应该是a0…an是否参与反馈，这种一般都会有一个周期  </li>
</ul>
<h4 id="线性反馈移位寄存器的一元多项式表示"><a href="#线性反馈移位寄存器的一元多项式表示" class="headerlink" title="线性反馈移位寄存器的一元多项式表示"></a>线性反馈移位寄存器的一元多项式表示</h4><ul>
<li>形式<br>设n级线性移位寄存器的输出序列{ai}满足递推关系：<br><img src="/2021/120547052/19.png" alt=" "><br>对任何K&gt;=1成立，这种递推关系可用一个一元高次多项式<br><img src="/2021/120547052/20.png" alt=" "><br>表示，称这个多项式为LFSR的特征多项式  </li>
<li>相关定理  </li>
</ul>
<p>2.1定义及定理<br><img src="/2021/120547052/21.png" alt=" "><br>2.2定理及定义<br><img src="/2021/120547052/22.png" alt=" "><br><img src="/2021/120547052/23.png" alt=" "><br><img src="/2021/120547052/24.png" alt=" "><br>2.3定义及定理<br><img src="/2021/120547052/25.png" alt=" "><br><img src="/2021/120547052/26.png" alt=" "><br>2.4定理<br><img src="/2021/120547052/27.png" alt=" "><br>2.5定理<br><img src="/2021/120547052/28.png" alt=" "><br>2.4定义和2.6定理<br><img src="/2021/120547052/29.png" alt=" "><br><img src="/2021/120547052/30.png" alt=" ">  </p>
<h4 id="m序列的伪随机性"><a href="#m序列的伪随机性" class="headerlink" title="m序列的伪随机性"></a>m序列的伪随机性</h4><ul>
<li>流密码的安全性取决于密钥流的安全性  </li>
<li>游程的概念：00110：0的2游程、1的2游程、0的1游程  </li>
<li>定义2.5<br><img src="/2021/120547052/31.png" alt=" ">  </li>
<li>Golomb对伪随机周期序列提出了应满足的如下三个随机性公设：  </li>
</ul>
<p>1.在序列的一个周期内，0与1的个数相差至多为1<br>2.在序列的一个周期内，长为1的游程占游程总数的1/2，长为2的游程占游程总数的(1/2)^2,…,长为i的游程占游程总数的(1/2)^i,且在等长的游程中0的游程个数和1的游程个数相等<br>3.异自相关函数是一个常数  </p>
<ul>
<li>从密码系统的角度看，一个伪随机序列还应满足下面的条件:  </li>
</ul>
<p>1.{ai}的周期相当大<br>2.{ai}的确定在计算上是容易的<br>3.{ai}由密文及相应的明文的部分信息,不能确定整个{ai}  </p>
<ul>
<li>定理2.7<br><img src="/2021/120547052/32.png" alt=" ">  </li>
</ul>
<h4 id="m序列的破译"><a href="#m序列的破译" class="headerlink" title="m序列的破译"></a>m序列的破译</h4><p>例如：<br>设敌手得到密文串101101011110010和相应的明文串  011001111111001，因此可计算出相应的密钥流为110100100001011。进一步假定敌手还知道密钥流是使用5级线性反馈移位寄存器产生的，那么敌手可分别用密文串中的前10个比特和明文串中的前10个比特建立如下方程<br><img src="/2021/120547052/33.png" alt=" "><br>之后：<br><img src="/2021/120547052/34.png" alt=" "><br>最后得到：<br><img src="/2021/120547052/35.png" alt=" ">  </p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">wwq</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://wwqstudy.github.io/2021/120547052.html">http://wwqstudy.github.io/2021/120547052.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">wwq</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/011152450.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="od使用">
                        
                        <span class="card-title">od使用</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-01-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            wwq
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/120454815.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="逆向题">
                        
                        <span class="card-title">逆向题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-12-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            wwq
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">wwq</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/wwqstudy" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1457060849@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1457060849" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1457060849" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":170,"height":340},"mobile":{"show":true},"log":false});</script></body>

</html>
